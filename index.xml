<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jane - A super concise theme for Hugo</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 24 Dec 2019 13:34:36 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于我对前端的理解</title>
      <link>http://localhost:1313/post/%E6%88%91%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Tue, 24 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E6%88%91%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      
        <description>

&lt;p&gt;前端工程师是最贴近用户的程序员，前端工作可以实现页面交互，提升用户体验，参与项目开发，快速、高质量地完成实现效果图，精准到1px。
与团队成员如UI设计人员、产品经理、测试人员沟通。做好页面结构、页面重构，提升用户体验。处理hack，兼容性问题，写出优美的代码。好的代码应具有高复用率，低耦合度，易维护，易扩展等特点。此外，针对各种问题进行优化，拥抱最新的前端技术。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;font color=&#34;#8B3A3A&#34;&gt;目前，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。这样的现状就引发了一系列的问题。&lt;/p&gt;

&lt;p&gt;首先是前端的基础知识，常常看到一些大佬认为很基础的JavaScript语法的时候，惊呼“居然可以这样”。基础知识的欠缺会让人感觉束手束脚，限制了解决问题的思路。&lt;/p&gt;

&lt;p&gt;其次，技术上存在短板，就会导致前端开发者的上升通道不甚顺畅。特别是一些小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展。&lt;/p&gt;

&lt;p&gt;除此之外，前端工程师也会面临技术发展问题带来的挑战。前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。我们就拿 JavaScript 标准来说，ES6 中引入的新特性超过了过去十年的总和，新特性带来的实践就更多了，仅仅是一个 Proxy 特性的引入，就支持了 VueJS 从 2.0 到 3.0 的内核原理完全升级。缺少系统教育 + 技术快速革新，在这样的大环境下，前端工程师保持自学能力就显得尤其重要。
&lt;/font&gt;
&lt;hr&gt;&lt;/p&gt;

&lt;p&gt;前端技术大致分为几个部分&lt;/p&gt;

&lt;h3 id=&#34;html-和-css&#34;&gt;HTML 和 CSS&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/HTMLCSS.png&#34; alt=&#34;htmlcss&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 HTML 的部分，我们按照功能和语言来划分它的知识，HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类。&lt;/p&gt;

&lt;p&gt;我们都知道 HTML 的标签可以分为很多种，head 里面的我们称为元信息类标签，诸如 title、meta、style、link、base 这些，它们用来描述文档的一些基本信息。&lt;/p&gt;

&lt;p&gt;还有一类是一些诸如 section、nav 的标签，它们在视觉表现上跟 div 并没有区别，但是各有各的适用场景，我们把它们称作语义类标签。&lt;/p&gt;

&lt;p&gt;另外一类是 img、video、audio 之类的替换型媒体类标签，用来引入外部内容，平常开发中你也会经常用到。&lt;/p&gt;

&lt;p&gt;再有就是表单类的，比如 input、button。&lt;/p&gt;

&lt;p&gt;除了标签之外，我们还应该把 HTML 当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，包括HTML的语法和几个重要的语言机制：实体、命名空间。此外，包括HTML的补充标准：ARIA，它是HTML的扩展，在可访问性领域，它有至关重要的作用。&lt;/p&gt;

&lt;p&gt;CSS部分，按照惯例从语言和功能两个角度来说。在语言部分，从大到小包括CSS的各种语法结构，比如 @rule、选择器、单位等等。功能部分，我们大致可以分为布局、绘制和交互类。布局类中两个最常用的布局：正常流和弹性布局。绘制类分为图形相关的和文字相关的绘制。最后动画和其它交互。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/JS.png&#34; alt=&#34;js&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时。&lt;/p&gt;

&lt;p&gt;接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：&lt;/p&gt;

&lt;p&gt;数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。&lt;/p&gt;

&lt;p&gt;所谓的算法，就是 JavaScript 的执行过程。类型部分中，对象比其它所有类型加起来都要更为复杂，包括它的一些历史和设计思路。&lt;/p&gt;

&lt;p&gt;执行过程则按照从大结构到小结构的角度，从最顶层的程序与模块、事件循环和微任务，到函数、再到语句级的执行。从粗到细地了解执行过程。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;浏览器的实现原理和api&#34;&gt;浏览器的实现原理和API&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/浏览器的实现原理和API.png&#34; alt=&#34;浏览器的实现原理和API&#34; /&gt;&lt;/p&gt;

&lt;p&gt;浏览器部分包括浏览器的实现原理，这是深入理解 API 的基础。
从一般的浏览器设计出发，按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来解释浏览器的工作原理。在 API 部分，主要有：事件、DOM、CSSOM 几个部分，它们分别覆盖了交互、语义和可见效果。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS的继承</title>
      <link>http://localhost:1313/post/js%E7%9A%84%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 23 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E7%9A%84%E7%BB%A7%E6%89%BF/</guid>
      
        <description>

&lt;h3 id=&#34;基于原型的继承&#34;&gt;基于原型的继承&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Animal () {
  this.x = 1
}
Animal.prototype.move = function() {
  console.log(&#39;Animal-move&#39;)
}

function Dog () {
  Animal.apply(this, arguments)
  this.xx = 2
}

let f = function() {}
f.prototype = Animal.prototype
Dog.prototype = new f()

Dog.prototype.constructor = Dog

Dog.prototype.run = function(){
  console.log(&#39;Dog-run&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let f = function() {}
f.prototype = Animal.prototype
Dog.prototype = new f()

Dog.prototype.constructor = Dog
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基于-class-的继承&#34;&gt;基于 class 的继承&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Animal {
  constructor () {
    this.x = 1
  }
  move() {
    console.log(&#39;Animal-move&#39;)
  }
}
class Dog extends Animal {
  constructor () {
    super()
    this.xx = 2
  }
  run() {
    console.log(&#39;Dog-run&#39;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Dog extends Animal {
  constructor () {
    super()
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>事件机制</title>
      <link>http://localhost:1313/post/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 23 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</guid>
      
        <description>

&lt;h3 id=&#34;什么是事件委托&#34;&gt;什么是事件委托&lt;/h3&gt;

&lt;p&gt;事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown&amp;hellip;&amp;hellip;）的函数委托到另一个元素；
一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。&lt;/p&gt;

&lt;h4 id=&#34;事件触发三阶段&#34;&gt;事件触发三阶段&lt;/h4&gt;

&lt;p&gt;首先事件触发有三个阶段&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从document往事件触发处传播，遇到注册的捕获事件会触发&lt;/li&gt;
&lt;li&gt;传播到事件触发处时触发注册的事件&lt;/li&gt;
&lt;li&gt;从事件触发处往document传播，遇到注册的冒泡事件会触发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和和捕获事件，事件触发会按照注册的顺序执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//以下会先打印冒泡然后是捕获
node.addEventListener(&#39;click&#39;, (event) =&amp;gt; {
    console.log(&#39;冒泡&#39;)
}, false)
node.addEventListener(&#39;click&#39;, (event) =&amp;gt; {
    console.log(&#39;捕获&#39;)
}, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;注册事件&#34;&gt;注册事件&lt;/h4&gt;

&lt;p&gt;通常我们使用addEventListener注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值useCapture参数，该参数默认值为false。useCapture决定了注册的事件是捕获事件还是冒泡事件。对于对象参数。可以使用以下几个属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;capture,布尔值，和useCapture作用一样&lt;/li&gt;
&lt;li&gt;once, 布尔值，值为true表示该回调只会调用一次，调用后会移除监听&lt;/li&gt;
&lt;li&gt;passive，布尔值，表示永远不会调用preventDefault&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，我们只希望事件只触发在目标上，这时候可以使用stopPropagation来阻止事件的进一步传播。通常我们认为stopPropagation是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation同样也能实现阻止事件，此外还能阻止该事件目标执行别的注册事件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;node.addEventListener(&#39;click&#39;, (event)=&amp;gt;{
    event.stopImmediatePropagation()
    console.log(&#39;冒泡&#39;)
}, false)
//点击node只会执行上面的函数，该函数不会执行
node.addEventListener(&#39;click&#39;, (event)=&amp;gt;{
    console.log(&#39;捕获&#39;)
}, true)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;事件代理&#34;&gt;事件代理&lt;/h4&gt;

&lt;p&gt;如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;ul id=&amp;quot;ul&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;script&amp;gt;
    ```
    let ul = document.querySelector(&#39;#ul&#39;)
    ul.addEventListener(&#39;click&#39;, (event) =&amp;gt; {
        console.log(event.target)
    })
    ```
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事件代理的方式相对于直接给目标注册事件，有以下优点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;节省内存&lt;/li&gt;
&lt;li&gt;不需要给子节点注销事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;怎么阻止默认动作&#34;&gt;怎么阻止默认动作&lt;/h3&gt;

&lt;p&gt;preventDefault它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;，提交按钮&lt;code&gt;&amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;&lt;/code&gt;等。当Event 对象的 cancelable为false时，表示没有默认行为，这时即使有默认行为，调用preventDefault也是不会起作用的。&lt;/p&gt;

&lt;h3 id=&#34;怎么阻止事件冒泡&#34;&gt;怎么阻止事件冒泡&lt;/h3&gt;

&lt;p&gt;stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。上面也说到，stopImmediatePropagation同样也能实现阻止事件，此外还能阻止该事件目标执行别的注册事件。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>跨域问题</title>
      <link>http://localhost:1313/post/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 22 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</guid>
      
        <description>

&lt;h3 id=&#34;什么是同源&#34;&gt;什么是同源&lt;/h3&gt;

&lt;p&gt;源 = 协议 + 域名 + 端口号&lt;br&gt;
window.origin或location.origin可以得到当前源&lt;/p&gt;

&lt;p&gt;如果两个url的&lt;font color=green&gt;协议 域名 端口号&lt;/font&gt;全都一致&lt;br&gt;
那么这两个url就是同源的！&lt;/p&gt;

&lt;h3 id=&#34;什么是跨域&#34;&gt;什么是跨域&lt;/h3&gt;

&lt;p&gt;因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax请求会失败
在一些情况下我们希望让不同源之间相互访问数据&lt;/p&gt;

&lt;h3 id=&#34;jsonp跨域&#34;&gt;JSONP跨域&lt;/h3&gt;

&lt;p&gt;JSONP就是利用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签没有跨域限制的漏洞。通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签指向一个需要访问的地址并提供一个回调函数当需要通讯时来接收数据
JSONP使用简单且兼容性不错，但是只限于get请求。
在开发中可能会遇到多个JSONP请求的回调函数名是相同的，这时候就需要自己封装一个JSONP&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function jsonp(url) {
    return new Promise((resolve, reject)=&amp;gt;{
        const random = Math.random()
        window[random] = (data) =&amp;gt; {
            resolve(data)
        }
        
        const script = document.createElement(&#39;script&#39;)
        script.src = `${url}?callback=${random}`
        script.type = &#39;text/javascript&#39;
        script.onload = () =&amp;gt; {
            script.remove()
        }
        script.onerror = () =&amp;gt; {
            reject()
        }
        document.body.appendChild(script)
    })
}

jsonp(&#39;http://127.0.0.1:8888/friends.js&#39;).then(
    (data) =&amp;gt; {
        console.log(data)
    }
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cors跨域&#34;&gt;CORS跨域&lt;/h3&gt;

&lt;p&gt;CORS需要浏览器和后端同时支持。IE8和9需要通过XDomainRequest来实现。&lt;/p&gt;

&lt;p&gt;浏览器会自动进行CORS通信，实现CORS通信的关键是后端。只要后端实现了CORS，就实现了跨域。&lt;/p&gt;

&lt;p&gt;服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if(path === &#39;/friends.json&#39;){
    response.statusCode = 200
    response.setHeader(&#39;Content-Type&#39;, &#39;text/json;charset=utf-8&#39;)
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://127.0.0.1:8888&#39;)
    response.write(fs.readFileSync(&#39;./public/friends.json&#39;))
    response.end()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Promise介绍</title>
      <link>http://localhost:1313/post/promise%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 18 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/promise%E4%BB%8B%E7%BB%8D/</guid>
      
        <description>

&lt;h3 id=&#34;promise-的用途&#34;&gt;Promise 的用途&lt;/h3&gt;

&lt;p&gt;Promise是ES6新增的语法，解决了回调地狱的问题&lt;/p&gt;

&lt;p&gt;Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.&lt;/p&gt;

&lt;p&gt;Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象&lt;/p&gt;

&lt;p&gt;一个 Promise有以下几种状态:&lt;/p&gt;

&lt;p&gt;pending: 初始状态，既不是成功，也不是失败状态。
fulfilled: 意味着操作成功完成。
rejected: 意味着操作失败。
pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。&lt;/p&gt;

&lt;p&gt;因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。&lt;/p&gt;

&lt;h3 id=&#34;创建一个-new-promise&#34;&gt;创建一个 new Promise&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function fn(){
    return new Promise((resolve, reject)=&amp;gt;{
        成功时调用 resolve(数据)
        失败时调用 reject(错误)
    })
}
fn().then(success, fail).then(success2, fail2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-promise-prototype-then&#34;&gt;使用 Promise.prototype.then&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var p1 = new Promise((resolve, reject) =&amp;gt; {
  resolve(&#39;成功！&#39;);
  // or
  // reject(new Error(&amp;quot;出错了！&amp;quot;));
});

p1.then(value =&amp;gt; {
  console.log(value); // 成功！
}, reason =&amp;gt; {
  console.error(reason); // 出错了！
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then函数会返回一个Promise实例，并且该返回值是一个新的实例而不是之前的实例
当一个值只是从一个 then 内部返回时，它将等价地返回 Promise.resolve(&amp;lt;由被调用的处理程序返回的值&amp;gt;)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var p2 = new Promise(function(resolve, reject) {
  resolve(1);
});

p2.then(function(value) {
  console.log(value); // 1
  return value + 1;
}).then(function(value) {
  console.log(value + &#39; - A synchronous value works&#39;);
  //2 - A synchronous value works
});

p2.then(function(value) {
  console.log(value); // 1
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-promise-all&#34;&gt;使用 Promise.all&lt;/h3&gt;

&lt;p&gt;Promise.all([promise1, promise2]).then(success1, fail1)&lt;br&gt;
promise1和promise2都成功才会调用success1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var p1 = Promise.resolve(3);
var p2 = 1337;
var p3 = new Promise((resolve, reject) =&amp;gt; {
  setTimeout(resolve, 100, &#39;foo&#39;);
}); 

Promise.all([p1, p2, p3]).then(values =&amp;gt; { 
  console.log(values); // [3, 1337, &amp;quot;foo&amp;quot;] 
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-promise-race&#34;&gt;使用 Promise.race&lt;/h3&gt;

&lt;p&gt;Promise.race([promise1, promise2]).then(success1, fail1)&lt;br&gt;
方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var promise1 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 500, &#39;one&#39;);
});

var promise2 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, &#39;two&#39;);
});

Promise.race([promise1, promise2]).then(function(value) {
  console.log(value);
  // Both resolve, but promise2 is faster
});
// expected output: &amp;quot;two&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>JS数组去重</title>
      <link>http://localhost:1313/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Tue, 17 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      
        <description>

&lt;p&gt;著名面试题：
如何实现数组去重？
假设有数组 array = [1,5,2,3,4,2,3,1,3,4]
你要写一个函数 unique，使得
unique(array) 的值为 [1,5,2,3,4]
也就是把重复的值都去掉，只保留不重复的值。&lt;/p&gt;

&lt;p&gt;一个答案不使用 Set 实现
我们可以先使用sort()将数组进行排序
然后比较相邻元素是否相等，从而排除重复项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let arr = [1,5,2,3,4,2,3,1,3,4]
function unique (array) {
    let arr = array.sort()
    let result = [arr[0]]
    for (let i = 1; i &amp;lt; arr.length; i++) {
        arr[i] !== arr[i-1] &amp;amp;&amp;amp; result.push(arr[i])
    }
    return result
}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用 Set&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let arr = [1,5,2,3,4,2,3,1,3,4]
function unique (array) {
  return Array.from(new Set(arr))
  //或者[...new Set(arr)]
}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面方案的缺点是不支持对象去重，数组中出现对象的时候会出现问题&lt;/p&gt;

&lt;p&gt;我们可以使用 Map / WeakMap 以支持对象去重。&lt;/p&gt;

&lt;h4 id=&#34;map去重&#34;&gt;Map去重&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let arr = [
    {key: &#39;key&#39;, value: &#39;value&#39;},
    {key: &#39;key&#39;, value: &#39;value&#39;},
    {value: &#39;value&#39;, key: &#39;key&#39;},
    {name:&#39;name&#39;}]
function mySort(obj){
    return Object.keys(obj)
    .sort().reduce((a, v) =&amp;gt; {
    a[v] = obj[v]
    return a
    }, {})
}

function unique (array) {
  let arr = array
  //console.log(arr)
  let hashMap = new Map()
  let result = new Array()
  for (let i = 0; i &amp;lt; arr.length; i++) {
    let item = arr[i]
    item = mySort(item)
    item = JSON.stringify(item)
    if(hashMap.has(item)) { 
      hashMap.set(item, 2)
    } else {  
      hashMap.set(item, 1)
      result.push(arr[i])
    }
  } 
  //console.log(hashMap)
  return result
}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遇到对象中嵌套对象会出现问题
&lt;hr&gt;&lt;/p&gt;

&lt;h4 id=&#34;weakmap去重&#34;&gt;WeakMap去重&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let ob1 = {key: &#39;key&#39;, value: &#39;value&#39;}
let ob2 = {value: &#39;value&#39;, key: &#39;key&#39;}
let arr = [ob1,ob1,ob2]
function unique(array) {
  let wm = new WeakMap()
  for(let i = 0; i &amp;lt; array.length; i++){
    if(!wm.has(array[i])){
      wm.set(array[i], i)
    }
  }
  return wm
}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;WeakMap {{…} =&amp;gt; 0, {…} =&amp;gt; 2}
[[Entries]]
0: {Object =&amp;gt; 0}
key: {key: &amp;quot;key&amp;quot;, value: &amp;quot;value&amp;quot;}
value: 0
1: {Object =&amp;gt; 2}
key: {value: &amp;quot;value&amp;quot;, key: &amp;quot;key&amp;quot;}
value: 2
__proto__: WeakMap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遇到let arr = [&lt;br&gt;
    {key: &amp;lsquo;key&amp;rsquo;, value: &amp;lsquo;value&amp;rsquo;},&lt;br&gt;
    {key: &amp;lsquo;key&amp;rsquo;, value: &amp;lsquo;value&amp;rsquo;},&lt;br&gt;
    {value: &amp;lsquo;value&amp;rsquo;, key: &amp;lsquo;key&amp;rsquo;},&lt;br&gt;
    {name:&amp;lsquo;name&amp;rsquo;}]&lt;br&gt;
会出现问题&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>http知识点</title>
      <link>http://localhost:1313/post/http%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Thu, 12 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/http%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      
        <description>

&lt;h2 id=&#34;一-http-响应状态码&#34;&gt;一 HTTP 响应状态码&lt;/h2&gt;

&lt;p&gt;HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：&lt;br&gt;
1. 信息响应(100–199)&lt;br&gt;
2. 成功响应(200–299)&lt;br&gt;
3. 重定向(300–399)&lt;br&gt;
4. 客户端错误(400–499)&lt;br&gt;
5. 服务器错误 (500–599)。&lt;br&gt;
状态代码由 section 10 of RFC 2616定义&lt;/p&gt;

&lt;h3 id=&#34;信息响应&#34;&gt;信息响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
100 Continue&lt;br&gt;
这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;102 Processing (WebDAV)&lt;br&gt;
此代码表示服务器已收到并正在处理该请求，但没有响应可用。&lt;/p&gt;

&lt;p&gt;103 Early Hints
此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;成功响应&#34;&gt;成功响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
200 OK&lt;br&gt;
请求成功。&lt;br&gt;
成功的含义取决于HTTP方法：&lt;br&gt;
GET：资源已被提取并在消息正文中传输。&lt;br&gt;
POST：描述动作结果的资源在消息体中传输。&lt;br&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
201 Created
该请求已成功，并因此创建了一个新的资源。这通常是在POST请求.
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
202 Accepted
请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
204 No Content
服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。
&lt;br&gt;
205 Reset Content
服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。
&lt;br&gt;
206 Partial Content
服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。&lt;br&gt;
&lt;hr&gt;

### 重定向
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
301 Moved Permanently&lt;br&gt;
被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。&lt;br&gt;如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
302 Found&lt;br&gt;
请求的资源现在临时从不同的 URI 响应请求。&lt;br&gt;由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

303 See Other
对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
304 Not Modified
如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
307 Temporary Redirect&lt;br&gt;
请求的资源现在临时从不同的URI响应请求。&lt;br&gt;由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
&lt;br&gt;&lt;br&gt;
308 Permanent Redirect&lt;br&gt;
这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 &lt;br&gt;这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;hr&gt;

&lt;h3 id=&#34;客户端响应&#34;&gt;客户端响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
400 Bad Request&lt;br&gt;
1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;401 Unauthorized&lt;br&gt;
当前请求需要用户验证。&lt;br&gt;
该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
403 Forbidden&lt;br&gt;
服务器已经理解请求，但是拒绝执行它。&lt;br&gt;与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
404 Not Found&lt;br&gt;
请求失败，请求所希望得到的资源未被在服务器上发现。&lt;br&gt;
没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
408 Request Timeout&lt;br&gt;
请求超时。&lt;br&gt;客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;410 Gone
被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。&lt;/p&gt;

&lt;p&gt;411 Length Required
服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。&lt;/p&gt;

&lt;p&gt;413 Payload Too Large
服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/p&gt;

&lt;p&gt;414 URI Too Long
请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。&lt;/p&gt;

&lt;p&gt;418 I&amp;rsquo;m a teapot
服务器拒绝尝试用 “茶壶冲泡咖啡”。&lt;/p&gt;

&lt;p&gt;429 Too Many Requests
用户在给定的时间内发送了太多请求（“限制请求速率”）。&lt;/p&gt;

&lt;p&gt;431 Request Header Fields Too Large
服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。&lt;/p&gt;

&lt;p&gt;451 Unavailable For Legal Reasons
用户请求非法资源，例如：由政府审查的网页。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;服务端响应&#34;&gt;服务端响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
500 Internal Server Error
服务器遇到了不知道如何处理的情况。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;501 Not Implemented
此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。&lt;/p&gt;

&lt;p&gt;502 Bad Gateway
此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
503 Service Unavailable&lt;br&gt;
服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 &lt;br&gt;
请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
504 Gateway Timeout
当服务器作为网关，不能及时得到响应时返回此错误代码。&lt;/p&gt;

&lt;p&gt;505 HTTP Version Not Supported
服务器不支持请求中所使用的HTTP协议版本。&lt;/p&gt;

&lt;p&gt;511 Network Authentication Required
状态码指示客户端需要进行身份验证才能获得网络访问权限。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>闭包和执行上下文</title>
      <link>http://localhost:1313/post/%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Tue, 10 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      
        <description>

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/js0.png&#34; alt=&#34;闭包与函数&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-什么是闭包&#34;&gt;一 什么是闭包？&lt;/h2&gt;

&lt;p&gt;闭包翻译自英文单词closure，这是个不太好翻译的词。编译原理中，它是处理语法产生式的一个步骤；而在编程语言领域，它表示一种函数。&lt;/p&gt;

&lt;p&gt;闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。&lt;/p&gt;

&lt;p&gt;这个古典的闭包定义中，闭包包含两个部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境部分

&lt;ul&gt;
&lt;li&gt;环境&lt;/li&gt;
&lt;li&gt;标识符列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表达式部分&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在JavaScript中找到对应的闭包组成部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境部分

&lt;ul&gt;
&lt;li&gt;环境：函数的词法环境（执行上下文的一部分）&lt;/li&gt;
&lt;li&gt;标识符列表：函数中用到的未声明的变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表达式部分：函数体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;请看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function init() {
    var name = &amp;quot;Mozilla&amp;quot;; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数,一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
}
init();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数，仅在该函数体内可被获取。请注意，displayName() 内没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。&lt;/p&gt;

&lt;p&gt;这个词法作用域的例子描述了引擎是如何解析嵌套函数中的变量的。&lt;br&gt;
&lt;font color=&#34;#00796B&#34;&gt;词法（lexical）一词表明，词法作用域根据声明变量的位置来确定该变量可被访问的位置。嵌套函数可获取声明于外部作用域的函数。&lt;/font&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;现在来考虑以下例子 ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function makeFunc() {
    var name = &amp;quot;Mozilla&amp;quot;;
    function displayName() {
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这段代码和之前的 init() 示例的效果完全一样。其中的不同 — 也是有意思的地方 — 在于内部函数 displayName() 在执行前，被外部函数返回。&lt;/p&gt;

&lt;p&gt;这个谜题的答案是，&lt;font color=&#34;#00796B&#34;&gt;JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。&lt;/font&gt;在我们的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;下面是一个更有意思的示例 — makeAdder 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。&lt;/p&gt;

&lt;p&gt;从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。&lt;/p&gt;

&lt;p&gt;add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。&lt;/p&gt;

&lt;h2 id=&#34;二-闭包的用途是什么&#34;&gt;二 闭包的用途是什么？&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。&lt;/p&gt;

&lt;p&gt;在 Web 中，你想要这样做的情况特别常见。大部分我们所写的 JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。&lt;/p&gt;

&lt;p&gt;假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如header）的字号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
}

h1 {
  font-size: 1.5em;
}

h2 {
  font-size: 1.2em;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的文本尺寸调整按钮可以修改 body 元素的 font-size 属性，由于我们使用相对单位，页面中的其它元素也会相应地调整。&lt;/p&gt;

&lt;p&gt;以下是 JavaScript：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + &#39;px&#39;;
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;size12，size14 和 size16 三个函数将分别把 body 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.getElementById(&#39;size-12&#39;).onclick = size12;
document.getElementById(&#39;size-14&#39;).onclick = size14;
document.getElementById(&#39;size-16&#39;).onclick = size16;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;size-12&amp;quot;&amp;gt;12&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;size-14&amp;quot;&amp;gt;14&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;size-16&amp;quot;&amp;gt;16&amp;lt;/a&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。&lt;/p&gt;

&lt;p&gt;而 JavaScript 没有这种原生支持，但&lt;font color=&#34;#00796B&#34;&gt;我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var Counter = (function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }   
})();

console.log(Counter.value()); /* logs 0 */
Counter.increment();
Counter.increment();
console.log(Counter.value()); /* logs 2 */
Counter.decrement();
console.log(Counter.value()); /* logs 1 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。&lt;/p&gt;

&lt;p&gt;该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。&lt;/p&gt;

&lt;p&gt;这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。&lt;/p&gt;

&lt;p&gt;你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量Counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var makeCounter = function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }  
};

var Counter1 = makeCounter();
var Counter2 = makeCounter();
console.log(Counter1.value()); /* logs 0 */
Counter1.increment();
Counter1.increment();
console.log(Counter1.value()); /* logs 2 */
Counter1.decrement();
console.log(Counter1.value()); /* logs 1 */
console.log(Counter2.value()); /* logs 0 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意两个计数器 Counter1 和 Counter2 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 privateCounter 。&lt;/p&gt;

&lt;p&gt;每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。&lt;/font&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;此外，我们可以通过闭包特性，将代码封装，等待时机成熟的时候再使用，比如实现柯里化和反柯里化。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-闭包的缺点是什么&#34;&gt;三 闭包的缺点是什么？&lt;/h2&gt;

&lt;p&gt;如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。&lt;/p&gt;

&lt;p&gt;例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
  this.getName = function() {
    return this.name;
  };

  this.getMessage = function() {
    return this.message;
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}
// 不建议重新定义原型
// MyObject.prototype = {
//   getName: function() {
//     return this.name;
//   },
//   getMessage: function() {
//     return this.message;
//   }
// };
MyObject.prototype.getName = function() {
  return this.name;
};
MyObject.prototype.getMessage = function() {
  return this.message;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;此外，IE浏览器存有bug，IE在我们使用完闭包之后，依然回收不了闭包里面引用的变量。
但是这是 IE 的问题，不是闭包的问题。参见司徒正美的&lt;a href=&#34;https://www.cnblogs.com/rubylouvre/p/3345294.html&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>apply,call和bind</title>
      <link>http://localhost:1313/post/applycall%E5%92%8Cbind/</link>
      <pubDate>Sat, 07 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/applycall%E5%92%8Cbind/</guid>
      
        <description>

&lt;h2 id=&#34;一-apply&#34;&gt;一 apply&lt;/h2&gt;

&lt;h3 id=&#34;语法&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;func.apply(thisArg, [argsArray])&lt;/p&gt;

&lt;h4 id=&#34;参数&#34;&gt;参数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisArg
可选的。在 func 函数运行时使用的 this 值。
（注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;argsArray
可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。
如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。
(从ECMAScript 5 开始可以使用类数组对象。)&lt;/p&gt;

&lt;h4 id=&#34;返回值&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;调用这个指定this值(thisArg)和参数([argsArray])的函数(func)
调用函数的结果即它的返回值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// expected output: 2

//结果
//&amp;gt; 7
//&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;1. 用 apply 将数组添加到另一个数组&lt;/font&gt;&lt;br&gt;
我们可以使用push将元素追加到数组中。并且，因为push接受可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，在这种情况下，concat确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组。在这种情况下我们可以使用apply&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var array = [&#39;a&#39;, &#39;b&#39;];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, 0, 1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;2. 使用apply和内置函数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/* 找出数组中最大/小的数字 */
var numbers = [5, 6, 2, 3, 7];

/* 应用(apply) Math.min/Math.max 内置函数完成 */
var max = Math.max.apply(null, numbers); /* 基本等同于 Math.max(numbers[0], ...) 或 Math.max(5, 6, ..) */
var min = Math.min.apply(null, numbers);

/* 代码对比： 用简单循环完成 */
max = -Infinity, min = +Infinity;

for (var i = 0; i &amp;lt; numbers.length; i++) {
  if (numbers[i] &amp;gt; max)
    max = numbers[i];
  if (numbers[i] &amp;lt; min) 
    min = numbers[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当心：如果用上面的方式调用apply，会有超出JavaScript引擎的参数长度限制的风险。当你对一个方法传入非常多的参数（比如一万个）时，就非常有可能会导致越界问题, 这个临界值是根据不同的 JavaScript 引擎而定的（JavaScript 核心中已经做了硬编码  参数个数限制在65536），因为这个限制（实际上也是任何用到超大栈空间的行为的自然表现）是未指定的. 有些引擎会抛出异常。更糟糕的是其他引擎会直接限制传入到方法的参数个数，导致参数丢失。举个例子：如果某个引擎限制了方法参数最多为4个（实际真正的参数个数限制当然要高得多了, 这里只是打个比方）, 上面的代码中, 真正通过 apply传到目标方法中的参数为 5, 6, 2, 3 而不是完整的数组。&lt;/p&gt;

&lt;p&gt;如果你的参数数组可能非常大，那么推荐使用下面这种策略来处理：将参数数组切块后循环传入目标方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function minOfArray(arr) {
  let min = Infinity;
  // let QUANTUM = 32768;
  let QUANTUM = 2;

  for (let i = 0, len = arr.length; i &amp;lt; len; i += QUANTUM) {
    //防止越界
    let rightIndex = Math.min(i + QUANTUM, len);
    let origin = arr.slice(i, rightIndex);
    let submin = Math.min.apply(null, origin);
    min = Math.min(submin, min);
  }

  return min;
}

let min = minOfArray([5, 6, 2, 3, 7]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;3. 使用apply来链接构造器&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;你可以使用apply来链接一个对象构造器，类似于Java。在接下来的例子中我们会创建一个全局Function 对象的construct方法 ，来使你能够在构造器中使用一个类数组对象而非参数列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Function.prototype.construct = function (aArgs) {
  var oNew = Object.create(this.prototype);
  this.apply(oNew, aArgs);
  return oNew;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-call&#34;&gt;二 call&lt;/h2&gt;

&lt;h3 id=&#34;语法-1&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;function.call(thisArg, arg1, arg2, &amp;hellip;)&lt;/p&gt;

&lt;h4 id=&#34;参数-1&#34;&gt;参数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisArg
可选的。在 func 函数运行时使用的 this 值。
（注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arg1, arg2, &amp;hellip;
指定的参数列表。&lt;/p&gt;

&lt;h4 id=&#34;返回值-1&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;使用调用者提供的 this 值(thisArg)和参数(arg1, arg2, &amp;hellip;)调用该函数(function)
调用函数的结果即它的返回值。
若该方法没有返回值，则返回 undefined。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// expected output: 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结果
&amp;gt; 7
&amp;gt; 2&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用父构造函数&lt;br&gt;
在一个子构造函数中，你可以通过调用父构造函数的 call 方法来实现继承，类似于 Java 中的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Product(name, price) {
this.name = name;
this.price = price;
}

function Food(name, price) {
Product.call(this, name, price);
this.category = &#39;food&#39;;
}

function Toy(name, price) {
Product.call(this, name, price);
this.category = &#39;toy&#39;;
}

var cheese = new Food(&#39;feta&#39;, 5);
var fun = new Toy(&#39;robot&#39;, 40);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用 Food 和 Toy 构造函数创建的对象实例都会拥有在 Product 构造函数中添加的 name 属性和 price 属性,但 category 属性是在各自的构造函数中定义的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用匿名函数
在下例中的 for 循环体内，我们创建了一个匿名函数，然后通过调用该函数的 call 方法，将每个数组元素作为指定的 this 值执行了那个匿名函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var animals = [
{ species: &#39;Lion&#39;, name: &#39;King&#39; },
{ species: &#39;Whale&#39;, name: &#39;Fail&#39; }
];

for (var i = 0; i &amp;lt; animals.length; i++) {
(function(i) {
this.print = function() {
  console.log(&#39;#&#39; + i + &#39; &#39; + this.species
              + &#39;: &#39; + this.name);
}
this.print();
}).call(animals[i], i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个匿名函数的主要目的是给每个数组元素对象添加一个 print 方法，这个 print 方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为 this 值传入那个匿名函数（普通参数就可以），目的是为了演示 call 的用法。
3. 使用 call 方法调用函数并且指定上下文的 &amp;lsquo;this&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function greet() {
  var reply = [this.animal, &#39;typically sleep between&#39;, this.sleepDuration].join(&#39; &#39;);
  console.log(reply);
}

var obj = {
  animal: &#39;cats&#39;, 
  sleepDuration: &#39;12 and 16 hours&#39;
};

greet.call(obj);  // cats typically sleep between 12 and 16 hours
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用 greet 方法的时候，该方法的this值会绑定到 obj 对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用函数并且不指定第一个参数（argument）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var sData = &#39;Wisen&#39;;

function display() {
console.log(&#39;sData value is %s &#39;, this.sData);
}

display.call();  // sData value is Wisen
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们调用了 display 方法，但并没有传递它的第一个参数。如果没有传递第一个参数，this 的值将会被绑定为全局对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&#39;use strict&#39;;

var sData = &#39;Wisen&#39;;

function display() {
  console.log(&#39;sData value is %s &#39;, this.sData);
}

display.call(); // Cannot read the property of &#39;sData&#39; of undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在严格模式下，this 的值将会是 undefined&lt;/p&gt;

&lt;h2 id=&#34;三-bind&#34;&gt;三 bind&lt;/h2&gt;

&lt;p&gt;bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
}

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语法-2&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;function.bind(thisArg[, arg1[, arg2[, &amp;hellip;]]])&lt;/p&gt;

&lt;h4 id=&#34;参数-2&#34;&gt;参数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;thisArg
调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。&lt;/li&gt;
&lt;li&gt;arg1, arg2, &amp;hellip;
当目标函数被调用时，被预置入绑定函数的参数列表中的参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;返回值-2&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。&lt;/p&gt;

&lt;h3 id=&#34;示例-2&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;#F5B041&#34;&gt;1. 创建绑定函数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;this.x = 9;    // 在浏览器中，this 指向全局的 &amp;quot;window&amp;quot; 对象
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回 9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#F5B041&#34;&gt;2. 预设初始参数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function list() {
  return Array.prototype.slice.call(arguments);
}

function addArguments(arg1, arg2) {
    return arg1 + arg2
}

var list1 = list(1, 2, 3); // [1, 2, 3]

var result1 = addArguments(1, 2); // 3

// 创建一个函数，它拥有预设参数列表。
var leadingThirtysevenList = list.bind(null, 37);

// 创建一个函数，它拥有预设的第一个参数
var addThirtySeven = addArguments.bind(null, 37); 

var list2 = leadingThirtysevenList(); 
// [37]

var list3 = leadingThirtysevenList(1, 2, 3); 
// [37, 1, 2, 3]

var result2 = addThirtySeven(5); 
// 37 + 5 = 42 

var result3 = addThirtySeven(5, 10);
// 37 + 5 = 42 ，第二个参数被忽略
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>jQuery设计思想</title>
      <link>http://localhost:1313/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</link>
      <pubDate>Sun, 10 Nov 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</guid>
      
        <description>

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作。&lt;br&gt;
这是它区别于其他Javascript库的根本特点。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-jquery如何获取元素&#34;&gt;一 jQuery如何获取元素&lt;/h2&gt;

&lt;p&gt;使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。
选择表达式可以是CSS选择器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/css-selector.png&#34; alt=&#34;css-selector&#34; /&gt;&lt;/p&gt;

&lt;p&gt;也可以是&lt;a href=&#34;(https://www.jquery123.com/category/selectors/)&#34;&gt;jQuery特有的表达式&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;a:first&#39;) //选择网页中第一个a元素

$(&#39;tr:odd&#39;) //选择表格的奇数行

$(&#39;#myForm :input&#39;) // 选择表单中的input元素

$(&#39;div:visible&#39;) //选择可见的div元素

$(&#39;div:gt(2)&#39;) // 选择所有的div元素，除了前三个

$(&#39;div:animated&#39;) // 选择当前处于动画状态的div元素
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-jquery的链式操作是怎样的&#34;&gt;二 jQuery的链式操作是怎样的&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来。比如：&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;　$(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;Hello&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分解开来，就是下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;div&#39;) //找到div元素
  .find(&#39;h3&#39;) //选择其中的h3元素
  .eq(2) //选择第3个h3元素
  .html(&#39;Hello&#39;); //将它的内容改为Hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，
这个jQuery对象中就包括了那些可以对选中元素做一些操作的函数
所以不同操作可以连在一起。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;jQuery还提供了.end()方法，使得结果集可以后退一步：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/end.png&#34; alt=&#34;end&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-jquery如何创建元素&#34;&gt;三 jQuery如何创建元素&lt;/h2&gt;

&lt;p&gt;创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&#39;);

$(&#39;&amp;lt;li class=&amp;quot;new&amp;quot;&amp;gt;new list item&amp;lt;/li&amp;gt;&#39;);

$(&#39;ul&#39;).append(&#39;&amp;lt;li&amp;gt;list item&amp;lt;/li&amp;gt;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制元素使用.clone()。&lt;/p&gt;

&lt;p&gt;删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。&lt;/p&gt;

&lt;p&gt;清空元素内容（但是不删除该元素）使用.empty()。&lt;/p&gt;

&lt;h2 id=&#34;四-jquery如何移动元素&#34;&gt;四 jQuery如何移动元素&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;假定我们选中了一个div元素，需要把它移动到p元素后面。&lt;/p&gt;

&lt;p&gt;第一种方法是使用.insertAfter()，把div元素移动p元素后面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;div&#39;).insertAfter($(&#39;p&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种方法是使用.after()，把p元素加到div元素前面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;p&#39;).after($(&#39;div&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。&lt;/p&gt;

&lt;p&gt;使用这种模式的操作方法，一共有四对：
&lt;img src=&#34;http://localhost:1313/images/move.png&#34; alt=&#34;move&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-jquery如何修改元素的属性&#34;&gt;五 jQuery如何修改元素的属性&lt;/h2&gt;

&lt;p&gt;操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即&amp;rdquo;取值器&amp;rdquo;与&amp;rdquo;赋值器&amp;rdquo;合一。到底是取值还是赋值，由函数的参数决定。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;h1&#39;).html(); //html()没有参数，表示取出h1的值

$(&#39;h1&#39;).html(&#39;Hello&#39;); //html()有参数Hello，表示对h1进行赋值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见的取值和赋值函数如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/change.png&#34; alt=&#34;change&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html&#34;&gt;jQuery设计思想-阮一峰&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS函数的执行时机</title>
      <link>http://localhost:1313/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Sat, 26 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      
        <description>

&lt;h2 id=&#34;一-为什么如下代码会打印-6-个-6&#34;&gt;一 为什么如下代码会打印 6 个 6&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let i = 0
for(i = 0; i &amp;lt; 6; i++){
  setTimeout(()=&amp;gt;{
    console.log(i)
  },0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当setTimeout()的毫秒数设置为0的时候，是要先执行完函数调用栈中的代码，然后立即调用定时器。&lt;/p&gt;

&lt;p&gt;因为定时器都被放在了一个队列中，等待上下文的可执行代码运行完毕后，才开始运行定时器，也就是定时器才刚开始计时。代码中声明一个let全局变量i，然后在for循环中改变i，所以在定时器的方法执行的时候，变量i已经变成了6，所以输出的全部是6。&lt;/p&gt;

&lt;h2 id=&#34;二-让上面代码打印-0-1-2-3-4-5-的方法&#34;&gt;二 让上面代码打印 0、1、2、3、4、5 的方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;for(let i = 0; i &amp;lt; 6; i++){
  setTimeout(() =&amp;gt; {
    console.log(i)
  }, 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout1.png&#34; alt=&#34;setTimeout1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;利用ES6 let命令声明变量块级作用域的概念，和前面for循环使用全局变量i不同，当前的i只在本轮循环有效， 所以每一次循环的i其实都是一个新的变量，所以5个setTimeout回调函数虽然都引用了变量i,但实际上这5个i是独立的，仅在自己的块级作用域内有效&lt;/p&gt;

&lt;h2 id=&#34;三-除了使用-for-let-配合-还有什么其他方法可以打印出-0-1-2-3-4-5&#34;&gt;三 除了使用 for let 配合，还有什么其他方法可以打印出 0、1、2、3、4、5&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let i
for (i = 0; i &amp;lt; 6; i++) {
  // j = i
  !(function(j) { 
    setTimeout(() =&amp;gt; {
      console.log(j)
    }, 0);
  })(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout2.png&#34; alt=&#34;setTimeout2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过立即执行函数创造了n个不同的函数作用域，给setTimeout传入n个不同的参数，所以就可以打印出0、1、2、3、4、5
此外，我们还可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let output = function(i) {
  setTimeout(function() {
    console.log(i);
  }, 0);
};
let i
for (i = 0; i &amp;lt; 6; i++) {
  output.call(undefined, i); // 这里传过去的 i 值被复制，而不是引用
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout3.png&#34; alt=&#34;setTimeout3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原理和上面相似，也是创造了n个不同的函数作用域，给setTimeout传入了n个不同的参数&lt;/p&gt;

&lt;p&gt;此外我们还可以利用setTimeout第三个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let i
for (i = 0; i &amp;lt; 6; i++) {
  setTimeout(function(i) {
    console.log(i);
  }, 0, i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout4.png&#34; alt=&#34;setTimeout4&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS排序算法</title>
      <link>http://localhost:1313/post/js%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-选择排序&#34;&gt;一 选择排序&lt;/h2&gt;

&lt;p&gt;选择排序 即在当前区间选出一个最小值和区间第一个数交换位置，区间大小减一&lt;br&gt;
一共有n个数， 第一次遍历n个数，第二次遍历n-1个数，以此类推，&lt;br&gt;
共遍历 n + (n - 1) + (n - 2) + &amp;hellip; + (n - n + 1) + (n - n) 次 (加0不影响最终结果)&lt;br&gt;
例如   数组一共有5个数，遍历 5 + 4 + 3 + 2 + 1 + 0 次&lt;br&gt;
也可以写作 n + &amp;hellip; + 3 + 2 + 1 + 0 = (n * (n + 1)) / 2 = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;(n^2) + (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)n &lt;br&gt;
时间复杂度O(n^2)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const log = console.log.bind(console)

//求当前区间内最小值下标
let minIndex = (numbers) =&amp;gt; {
  let index = 0
  for(let i = 1; i &amp;lt; numbers.length; i++){
    if(numbers[i] &amp;lt; numbers[index]){
      index = i
    }
  }
  return index
}

let swap = (array, i, j) =&amp;gt; {
  let temp = array[i]
  array[i] = array[j]
  array[j] = temp
}

let sort = (numbers) =&amp;gt; {
  //遍历到区间只剩下两个数就可以停止了, 也就是i等于numbers.length - 2
  //如8个数 i等于numbers.length - 2 = 6, 区间是arr[6]-arr[7] 没有arr[8] :)
  for(let i = 0; i &amp;lt; numbers.length - 1; i++){
    log(`------`)
    log(`i: ${i}`)
    //求当前区间内的最小值在整个数组内的下标
    //为当前区间内的最小值的下标 加 区间前面的数字个数
    //例如 [6,2,4,5]  1 + 0
    //再比如 6,[2,4,5] 0 + 1
    let index = minIndex(numbers.slice(i)) + i
    log(`index: ${index}`)
    log(`min: ${numbers[index]}`)
    if(index!==i){
      swap(numbers, index, i)
      log(`swap ${index}:${i}`)
      log(numbers)
    }
  }
  return numbers
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-快速排序&#34;&gt;二 快速排序&lt;/h2&gt;

&lt;p&gt;快速排序,即取数组中间位置的数，比它小的数放在它的左边，比它大的放在右边
然后区间变为它的左边的数组成的数组 和 它的右边的数组成的数组
最后区间只剩一个数终止&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let quickSort = arr =&amp;gt; {
  if (arr.length &amp;lt;= 1) { 
    return arr; 
  }
  let pivotIndex = Math.floor(arr.length / 2);
  let pivot = arr.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i &amp;lt; arr.length; i++){
    if (arr[i] &amp;lt; pivot) { 
      left.push(arr[i])
    } else { 
      right.push(arr[i]) 
    }
  }
  return quickSort(left).concat([pivot], quickSort(right))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-归并排序&#34;&gt;三 归并排序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let merge = (a, b) =&amp;gt; {
  if (a.length === 0) {
    return b
  }
  if (b.length === 0) {
    return a
  }
  return a[0] &amp;gt; b[0] ?
    [b[0]].concat(merge(a, b.slice(1))) :
    [a[0]].concat(merge(a.slice(1), b))
}

let mergeSort = arr =&amp;gt; {
  let k = arr.length
  if (k === 1) { 
    return arr
  }
  let left = arr.slice(0, Math.floor(k / 2))
  let right = arr.slice(Math.floor(k / 2))
  return merge(mergeSort(left), mergeSort(right))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-计数排序&#34;&gt;四 计数排序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let countSort = arr =&amp;gt; {
  let hashTable = {}, max = 0, result = []
  for(let i = 0; i &amp;lt; arr.length; i++){ 
    if(!(arr[i] in hashTable)){ 
      hashTable[arr[i]] = 1
    }else{
      hashTable[arr[i]] += 1
    }
    if(max &amp;lt; arr[i]) {
      max = arr[i]
    }
  }
  for(let j = 0; j &amp;lt;= max; j++){ 
    if(j in hashTable){
      for(let i = 0; i &amp;lt; hashTable[j]; i++){
        result.push(j)
      }
    }
  }
  return result
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间不够，待更新&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS对象基本用法</title>
      <link>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sun, 20 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-声明对象的两种语法&#34;&gt;一 声明对象的两种语法&lt;/h2&gt;

&lt;h3 id=&#34;对象的定义&#34;&gt;对象的定义&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;无序的数据集合&lt;/font&gt;&lt;br&gt;
&lt;font color=&#34;orange&#34;&gt;键值对的集合&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;对象的写法&#34;&gt;对象的写法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;let obj = {&#39;name&#39;: &#39;zwx&#39;, &#39;age&#39;: 18, }&lt;/code&gt;
&lt;code&gt;let obj = new Object({&#39;name&#39;: &#39;zwx&#39;})&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;细节&#34;&gt;细节&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;键名是字符串，可以包含任意Unicode字符&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;如果书写键名时省略引号，就只能按标识符规则书写&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;‘省略引号’也改变不了‘键名是个字符串’这个事实&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-如何删除对象的属性&#34;&gt;二 如何删除对象的属性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;delete obj.xxx&lt;/code&gt;或者&lt;code&gt;delete obj[&#39;xxx&#39;]&lt;/code&gt;
&lt;font color=&#34;orange&#34;&gt;即可删除obj的xxx属性&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;不含属性名&lt;/font&gt;
&lt;code&gt;&#39;xxx&#39; in obj === false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;含有属性名，但是值为undefined&lt;/font&gt;
&lt;code&gt;&#39;xxx&#39; in obj &amp;amp;&amp;amp; obj.xxx === undefined&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-如何查看对象的属性&#34;&gt;三 如何查看对象的属性&lt;/h2&gt;

&lt;h3 id=&#34;查看所有属性&#34;&gt;查看所有属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;查看自身所有属性&lt;/font&gt;
&lt;code&gt;Object.keys(obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;查看自身+共有属性&lt;/font&gt;
&lt;code&gt;console.dir(obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;判断一个属性是自身的还是共有的&lt;/font&gt;
&lt;code&gt;obj.hasOwnProperty(&#39;toString&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看属性&#34;&gt;查看属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;中括号语法：&lt;/font&gt;
&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt;
&lt;font color=&#34;orange&#34;&gt;点语法：&lt;/font&gt;
&lt;code&gt;obj.key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;优先使用&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt;&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;重点&#34;&gt;重点&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;obj.name 等价于 obj[&amp;lsquo;name&amp;rsquo;]&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let my = function(){
let list = [&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;]
let person = {
  name: &#39;zwx&#39;,
  age: 18,
  gender: &#39;male&#39;,
}
for (let i = 0; i &amp;lt; list.length; i++) {
  let name = list[i]
  //person.name 等价于 person[&#39;name&#39;]
  console.log(&#39;1.&#39; + person.name)
  console.log(&#39;2.&#39; + person[name])
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/查看对象属性.png&#34; alt=&#34;查看对象属性&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;四-如何修改或增加对象的属性&#34;&gt;四 如何修改或增加对象的属性&lt;/h2&gt;

&lt;h3 id=&#34;修改或增加属性&#34;&gt;修改或增加属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;直接赋值&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;let obj = {name: &#39;zwx&#39;} // name是字符串&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj.name = &#39;zwx&#39; // name是字符串&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj[&#39;name&#39;] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj[&#39;na&#39; + &#39;me&#39;] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;let key = &#39;name&#39;; obj[key] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;批量赋值&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.assign(obj, {age: 18, gender: &#39;male&#39;})&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;修改或增加共有属性&#34;&gt;修改或增加共有属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;无法通过其中一个对象修改或增加他们的共有属性&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let obj = {}, obj2 = {} // 共有原型上的toString&lt;/code&gt;&lt;br&gt;
&lt;code&gt;obj.toString = &#39;xxx&#39;&lt;/code&gt; 只会修改自身的属性&lt;br&gt;
&lt;code&gt;obj2.toString&lt;/code&gt; 还是原型上的方法&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;我偏要修改或增加原型上的属性&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;obj.__proto__.toString = &#39;xxx&#39; // 不推荐用__proto__&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Object.prototype.toString = &#39;xxx&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;一般来说，不要修改原型，会引起很多问题&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-name-in-obj和obj-hasownproperty-name-的区别&#34;&gt;五 &amp;lsquo;name&amp;rsquo; in obj和obj.hasOwnProperty(&amp;lsquo;name&amp;rsquo;)的区别&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;prop in object&lt;/code&gt; 检查它（或其原型链）是否包含具有指定名称的属性&lt;/p&gt;

&lt;p&gt;in右操作数必须是一个对象值。&lt;/p&gt;

&lt;p&gt;如果使用 delete 运算符删除了一个属性，则 in 运算符对所删除属性返回 false。&lt;/p&gt;

&lt;p&gt;如果你只是将一个属性的值赋值为undefined，而没有删除它，则 in 运算仍然会返回true。&lt;/p&gt;

&lt;p&gt;如果一个属性是从原型链上继承来的，in 运算符也会返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;obj.hasOwnProperty(&#39;name&#39;)&lt;/code&gt; 方法会返回一个布尔值，指示对象自身属性中（非继承属性）是否具有指定的属性，
如果 object 具有带指定名称的属性，则 hasOwnProperty 方法返回 true，否则返回 false。此方法不会检查对象原型链中的属性；该属性必须是对象本身的一个成员。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let father = {money: 9999}
let son = Object.create(father)
son.name = &#39;son&#39;
console.log(&#39;1.检查它（或其原型链）是否包含具有指定名称的属性&#39;)
console.log(&#39;money&#39; in son) //true
console.log(&#39;2.对象自身属性中（非继承属性）是否具有指定的属性&#39;)
console.log(son.hasOwnProperty(&#39;money&#39;)) //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/方法区别.png&#34; alt=&#34;方法区别&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS的基本语法</title>
      <link>http://localhost:1313/post/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-表达式和语句&#34;&gt;一 表达式和语句&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句（statement）是为了完成某种任务而进行的操作&lt;/font&gt;，比如下面就是一行赋值语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let a = 1 + 3;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这条语句先用&lt;code&gt;let&lt;/code&gt;命令，声明了变量&lt;code&gt;a&lt;/code&gt;，然后将&lt;code&gt;1 + 3&lt;/code&gt;的运算结果赋值给变量&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + 3&lt;/code&gt;叫做表达式（expression）&lt;/p&gt;

&lt;p&gt;表达式指一个为了得到返回值的计算式。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；
表达式则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。
比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let a = 1 + 3 ; let b = &#39;abc&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;;;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的代码就表示3个空语句。&lt;/p&gt;

&lt;p&gt;表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + 3;&lt;/code&gt;
&lt;code&gt;&#39;abc&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面两行语句只是单纯地产生一个值，并没有任何实际的意义。&lt;/p&gt;

&lt;h2 id=&#34;二-标识符的规则&#34;&gt;二 标识符的规则&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;标识符（identifier）指的是用来识别各种值的合法名称。&lt;/font&gt;最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;A&lt;/code&gt;是两个不同的标识符。&lt;/p&gt;

&lt;p&gt;标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript引擎遇到非法标识符，就会报错。&lt;/p&gt;

&lt;p&gt;简单说，标识符命名规则如下。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（&lt;code&gt;$&lt;/code&gt;）和下划线（&lt;code&gt;_&lt;/code&gt;）。
第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;。&lt;/font&gt;
下面这些都是合法的标识符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arg0&lt;/code&gt;
&lt;code&gt;_tmp&lt;/code&gt;
&lt;code&gt;$elem&lt;/code&gt;
&lt;code&gt;π&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面这些则是不合法的标识符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;1a  // 第一个字符不能是数字
23  // 同上
***  // 标识符不能包含星号
a+b  // 标识符不能包含加号
-d  // 标识符不能包含减号或连词线
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文是合法的标识符，可以用作变量名。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var 临时变量 = 1;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-if-else-条件语句&#34;&gt;三 if else 条件语句&lt;/h2&gt;

&lt;p&gt;if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，&lt;code&gt;true&lt;/code&gt;表示真，&lt;code&gt;false&lt;/code&gt;表示伪&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (布尔值)
  语句;

// 或者
if (布尔值) 语句;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3)
  m = m + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，只有在&lt;code&gt;m&lt;/code&gt;等于&lt;code&gt;3&lt;/code&gt;时，才会将其值加上&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3) {
  m += 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议总是在if语句中使用大括号，因为这样方便插入语句。&lt;/p&gt;

&lt;p&gt;注意，if后面的表达式之中，不要混淆赋值表达式（&lt;code&gt;=&lt;/code&gt;）、严格相等运算符（&lt;code&gt;===&lt;/code&gt;）和相等运算符（&lt;code&gt;==&lt;/code&gt;）。尤其是赋值表达式不具有比较作用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 1;
var y = 2;
if (x = y) {
  console.log(x);
}
// &amp;quot;2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的原意是，当&lt;code&gt;x&lt;/code&gt;等于&lt;code&gt;y&lt;/code&gt;的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将&lt;code&gt;y&lt;/code&gt;赋值给变量&lt;code&gt;x&lt;/code&gt;，再判断变量&lt;code&gt;x&lt;/code&gt;的值（等于&lt;code&gt;2&lt;/code&gt;）的布尔值（结果为&lt;code&gt;true&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (x = 2) { // 不报错
if (2 = x) { // 报错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;代码块后面，还可以跟一个&lt;code&gt;else&lt;/code&gt;代码块，表示不满足条件时，所要执行的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3) {
  // 满足条件时，执行的语句
} else {
  // 不满足条件时，执行的语句
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码判断变量&lt;code&gt;m&lt;/code&gt;是否等于&lt;code&gt;3&lt;/code&gt;，如果等于就执行&lt;code&gt;if&lt;/code&gt;代码块，否则执行&lt;code&gt;else&lt;/code&gt;代码块。&lt;/p&gt;

&lt;p&gt;对同一个变量进行多次判断时，多个&lt;code&gt;if...else&lt;/code&gt;语句可以连写在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 0) {
  // ...
} else if (m === 1) {
  // ...
} else if (m === 2) {
  // ...
} else {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;else&lt;/code&gt;代码块总是与离自己最近的那个&lt;code&gt;if&lt;/code&gt;语句配对。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var m = 1;
var n = 2;

if (m !== 1)
if (n === 2) console.log(&#39;hello&#39;);
else console.log(&#39;world&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码不会有任何输出，&lt;code&gt;else&lt;/code&gt;代码块不会得到执行，因为它跟着的是最近的那个&lt;code&gt;if&lt;/code&gt;语句，相当于下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m !== 1) {
  if (n === 2) {
    console.log(&#39;hello&#39;);
  } else {
    console.log(&#39;world&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想让&lt;code&gt;else&lt;/code&gt;代码块跟随最上面的那个if语句，就要改变大括号的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m !== 1) {
  if (n === 2) {
    console.log(&#39;hello&#39;);
  }
} else {
  console.log(&#39;world&#39;);
}
// world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-while-for-循环语句&#34;&gt;四 while for 循环语句&lt;/h2&gt;

&lt;h3 id=&#34;while语句&#34;&gt;While语句&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;While&lt;/code&gt;语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (条件)
  语句;

// 或者
while (条件) 语句;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;while&lt;/code&gt;语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (条件) {
  语句;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是&lt;code&gt;while&lt;/code&gt;语句的一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while (i &amp;lt; 100) {
  console.log(&#39;i 当前为：&#39; + i);
  i = i + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将循环100次，直到i等于100为止。&lt;/p&gt;

&lt;p&gt;下面的例子是一个无限循环，因为循环条件总是为真。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (true) {
  console.log(&#39;Hello, world&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for语句&#34;&gt;for语句&lt;/h3&gt;

&lt;p&gt;for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (初始化表达式; 条件; 递增表达式)
  语句

// 或者

for (初始化表达式; 条件; 递增表达式) {
  语句
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;for语句后面的括号里面，有三个表达式。&lt;/font&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;初始化表达式（initialize）&lt;/font&gt;：确定循环变量的初始值，只在循环开始时执行一次。&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;条件表达式（test）&lt;/font&gt;：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;递增表达式（increment）&lt;/font&gt;：每轮循环的最后一个操作，通常用来递增循环变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 3;
for (var i = 0; i &amp;lt; x; i++) {
  console.log(i);
}
// 0
// 1
// 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，初始化表达式是&lt;code&gt;var i = 0&lt;/code&gt;，即初始化一个变量&lt;code&gt;i&lt;/code&gt;；测试表达式是&lt;code&gt;i &amp;lt; x&lt;/code&gt;，即只要&lt;code&gt;i&lt;/code&gt;小于&lt;code&gt;x&lt;/code&gt;，就会执行循环；递增表达式是&lt;code&gt;i++&lt;/code&gt;，即每次循环结束后，&lt;code&gt;i&lt;/code&gt;增大&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所有&lt;code&gt;for&lt;/code&gt;循环，都可以改写成&lt;code&gt;while&lt;/code&gt;循环。上面的例子改为&lt;code&gt;while&lt;/code&gt;循环，代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 3;
var i = 0;

while (i &amp;lt; x) {
  console.log(i);
  i++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for ( ; ; ){
  console.log(&#39;Hello World&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。&lt;/p&gt;

&lt;h2 id=&#34;五-break-continue-语句&#34;&gt;五 break continue 语句&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句用于跳出代码块或循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while(i &amp;lt; 100) {
  console.log(&#39;i 当前为：&#39; + i);
  i++;
  if (i === 10) break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码只会执行10次循环，一旦i等于10，就会跳出循环。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;循环也可以使用&lt;code&gt;break&lt;/code&gt;语句跳出循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (var i = 0; i &amp;lt; 5; i++) {
  console.log(i);
  if (i === 3)
    break;
}
// 0
// 1
// 2
// 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码执行到&lt;code&gt;i&lt;/code&gt;等于&lt;code&gt;3&lt;/code&gt;，就会跳出循环。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while (i &amp;lt; 100){
  i++;
  if (i % 2 === 0) continue;
  console.log(&#39;i 当前为：&#39; + i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码只有在&lt;code&gt;i&lt;/code&gt;为奇数时，才会输出&lt;code&gt;i&lt;/code&gt;的值。如果&lt;code&gt;i&lt;/code&gt;为偶数，则直接进入下一轮循环。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;如果存在多重循环，不带参数的&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都只针对最内层循环。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;六-标签-label&#34;&gt;六 标签（label）&lt;/h2&gt;

&lt;p&gt;JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;label:
  语句
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。&lt;/p&gt;

&lt;p&gt;标签通常与&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句配合使用，跳出特定的循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) break top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为一个双重循环区块，&lt;code&gt;break&lt;/code&gt;命令后面加上了&lt;code&gt;top&lt;/code&gt;标签（注意，&lt;code&gt;top&lt;/code&gt;不用加引号），满足条件时，直接跳出双层循环。如果&lt;code&gt;break&lt;/code&gt;语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p&gt;

&lt;p&gt;标签也可以用于跳出代码块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;foo: {
  console.log(1);
  break foo;
  console.log(&#39;本行不会输出&#39;);
}
console.log(2);
// 1
// 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码执行到&lt;code&gt;break foo&lt;/code&gt;，就会跳出区块。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句也可以与标签配合使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) continue top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
// i=2, j=0
// i=2, j=1
// i=2, j=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;continue&lt;/code&gt;命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果&lt;code&gt;continue&lt;/code&gt;语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;面试相关题：&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//label
{
    top: x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://wangdoc.com/javascript/index.html&#34;&gt;网道JavaScript 教程&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Javascript的诞生</title>
      <link>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
      <pubDate>Sat, 21 Sep 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
      
        <description>

&lt;h2 id=&#34;一-javascript的诞生&#34;&gt;一 Javascript的诞生&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。&lt;/p&gt;

&lt;p&gt;网景公司当时有两个选择：一个是采用现有的语言，比如Perl、Python、Tcl、Scheme等等，允许它们直接嵌入网页；另一个是发明一种全新的语言。就在这时，发生了另外一件大事：1995年Sun公司将Oak语言改名为Java，正式向市场推出。Sun公司大肆宣传，许诺这种语言可以&amp;rdquo;一次编写，到处运行&amp;rdquo;（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。网景公司动了心，决定与Sun公司结成联盟。它不仅允许Java程序以applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。&lt;/p&gt;

&lt;p&gt;总之，当时的形势就是，网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。因此，Javascript后来就是网景和Sun两家公司一起携手推向市场的，这种语言被命名为&amp;rdquo;Java+script&amp;rdquo;并不是偶然的。&lt;/p&gt;

&lt;p&gt;此时，34岁的系统程序员Brendan Eich登场了。1995年4月，网景公司录用了他。一个月之后，1995年5月，网景公司做出决策，未来的网页脚本语言必须&amp;rdquo;看上去与Java足够相似&amp;rdquo;，但是比Java简单，使得非专业的网页作者也能很快上手。这个决策实际上将Perl、Python、Tcl、Scheme等非面向对象编程的语言都排除在外了。而Brendan Eich被指定为这种&amp;rdquo;简化版Java语言&amp;rdquo;的设计师。&lt;/p&gt;

&lt;p&gt;但是，他对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。总的来说，他的设计思路是这样的：&lt;br&gt;
1.借鉴C语言的基本语法；&lt;br&gt;
2.借鉴Java语言的数据类型和内存管理；&lt;br&gt;
3.借鉴Scheme语言，将函数提升到&amp;rdquo;第一等公民&amp;rdquo;（first class）的地位；&lt;br&gt;
4.借鉴Self语言，使用基于原型（prototype）的继承机制。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;如果不是公司的决策，Brendan Eich绝不可能把Java作为Javascript设计的原型。作为设计者，他一点也不喜欢自己的这个作品：&amp;rdquo;与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：&amp;rsquo;它的优秀之处并非原创，它的原创之处并不优秀。&amp;rsquo;（the part that is good is not original, and the part that is original is not good.）&amp;rdquo;&lt;br&gt;
所以，最后，Javascript语言实际上是两种语言风格的混合产物&amp;mdash;-（简化的）函数式编程+（简化的）面向对象编程。&lt;/p&gt;

&lt;h2 id=&#34;二-javascript的设计缺陷&#34;&gt;二 Javascript的设计缺陷&lt;/h2&gt;

&lt;p&gt;Javascript的设计，其实只用了十天。而且，设计师是为了向公司交差，本人并不愿意这样设计（参见《Javascript诞生记》）。&lt;/p&gt;

&lt;p&gt;另一方面，这种语言的设计初衷，是为了解决一些简单的网页互动（比如，检查&amp;rdquo;用户名&amp;rdquo;是否填写），并没有考虑复杂应用的需要。设计者做梦也想不到，Javascript将来可以写出像Gmail这种极其庞大复杂的网页。
Javascript同时结合了函数式编程和面向对象编程的特点，这很可能是历史上的第一例。而且直到今天为止，Javascript仍然是世界上唯一使用Prototype继承模型的主要语言。这使得它没有设计先例可以参考。
Javascript的发展非常快，根本没有时间调整设计。&lt;/p&gt;

&lt;p&gt;1995年5月，设计方案定稿；10月，解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。Javascript缺乏一个从小到大、慢慢积累用户的过程，而是连续的爆炸式扩散增长。大量的既成网页和业余网页设计者的参与，使得调整语言规格困难重重。&lt;/p&gt;

&lt;p&gt;更糟的是，Javascript的规格还没来及调整就固化了。&lt;/p&gt;

&lt;p&gt;1996年8月，微软公司强势介入，宣布推出自己的脚本语言Jscript；11月，为了压制微软，网景公司决定申请Javascript的国际标准；1997年6月，第一个国际标准ECMA-262正式颁布。&lt;/p&gt;

&lt;p&gt;也就是说，Javascript推出一年半之后，国际标准就问世了。设计缺陷还没有充分暴露就成了标准。相比之下，C语言问世将近20年之后，国际标准才颁布。&lt;/p&gt;

&lt;p&gt;Javascript的全局变量，在所有模块中都是可见的；任何一个函数内部都可以生成全局变量，这大大加剧了程序的复杂性。&lt;/p&gt;

&lt;p&gt;==用来判断两个值是否相等。当两个值类型不同时，会发生自动转换，得到的结果非常不符合直觉。
因此，推荐任何时候都使用&amp;rdquo;===&amp;ldquo;（精确判断）比较符。&lt;/p&gt;

&lt;p&gt;既然Javascript有缺陷，数量还不少，那么它是不是一种很糟糕的语言？有没有前途？&lt;/p&gt;

&lt;p&gt;回答是Javascript并不算糟糕，相反它的编程能力很强大，前途很光明。&lt;/p&gt;

&lt;p&gt;首先，如果遵守良好的编程规范，加上第三方函数库的帮助，Javascript的这些缺陷大部分可以回避。&lt;/p&gt;

&lt;p&gt;其次，Javascript目前是网页编程的唯一语言，只要互联网继续发展，它就必然一起发展。目前，许多新项目大大扩展了它的用途，node.js使得Javascript可以用于后端的服务器编程，coffeeScript使你可以用python和ruby的语法，撰写Javascript。&lt;/p&gt;

&lt;p&gt;最后，只要发布新版本的语言标准（比如 ECMAscript 5），就可以弥补这些设计缺陷。当然，标准的发布和标准的实现是两回事，上述的很多缺陷也许会一直伴随到Javascript存在的最后一天。&lt;/p&gt;

&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html&#34;&gt;Javascript诞生记&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html&#34;&gt;Javascript的10个设计缺陷&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://baike.baidu.com/item/javascript&#34;&gt;javascript&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 15 Sep 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>

&lt;h2 id=&#34;一-浏览器渲染过程&#34;&gt;一 浏览器渲染过程&lt;/h2&gt;

&lt;h4 id=&#34;概览步骤&#34;&gt;概览步骤&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;根据HTML构建HTML树（DOM）&lt;/li&gt;
&lt;li&gt;根据CSS构建CSS树（CSSOM）&lt;/li&gt;
&lt;li&gt;将两棵树合并成一颗渲染树（render tree）&lt;/li&gt;
&lt;li&gt;Layout布局（文档流、盒模型、计算大小和位置）&lt;/li&gt;
&lt;li&gt;Paint绘制（把边框颜色、文字颜色、阴影等画出来）&lt;/li&gt;
&lt;li&gt;Composite合成（根据层叠关系展示画面）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;三颗树图示&#34;&gt;三颗树图示&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/三颗树.png&#34; alt=&#34;三棵树&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;三种更新方式&#34;&gt;三种更新方式&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;第一种，全部步骤&lt;br&gt;
div.remove()会触发当前元素消失，其他元素re-layout&lt;br&gt;&lt;/li&gt;
&lt;li&gt;第二种，跳过layout&lt;br&gt;
改变背景颜色，直接repaint+composite&lt;br&gt;&lt;/li&gt;
&lt;li&gt;第三种，跳过layout和paint&lt;br&gt;
改变transform，只需composite&lt;br&gt;
注意！必须全屏查看效果，在iframe里看有问题&lt;br&gt;
图示如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/三种更新方式.png&#34; alt=&#34;三种更新方式&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-css属性之transition-过渡&#34;&gt;二 CSS属性之transition-过渡&lt;/h2&gt;

&lt;h4 id=&#34;transition作用-补充中间帧&#34;&gt;transition作用&amp;ndash;补充中间帧&lt;/h4&gt;

&lt;h4 id=&#34;transition语法如下&#34;&gt;transition语法如下&lt;/h4&gt;

&lt;p&gt;&lt;font color=#0099ff&gt;transition: 属性名 时长 过渡方式 延迟&lt;/font&gt;&lt;br&gt;
transition: left 200ms linear&lt;br&gt;
可以用逗号分隔两个不同属性&lt;br&gt;
transtion: left 200ms, top 400ms&lt;br&gt;
可以用all代表所有属性&lt;br&gt;
transition: all 200ms&lt;br&gt;
过渡方式有: linear|ease|ease-in|ease-out|ease-in-out&lt;br&gt;
cubic-bezier|step-start|step-end|steps&lt;br&gt;
具体细节参考数学相关&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=#FF7F50&gt;注意！并不是所有属性都能过渡&lt;/font&gt;&lt;br&gt;
display:none =&amp;gt; block没办法过渡&lt;br&gt;
一般改为visibility: hidden =&amp;gt; visible&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=#0099ff&gt;过渡必须要有起始&lt;/font&gt;&lt;br&gt;
一般只有一次动画，或者两次&lt;br&gt;
比如hover和非hover状态的过渡&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-css属性之animation-动画&#34;&gt;三 CSS属性之animation-动画&lt;/h2&gt;

&lt;h4 id=&#34;使用animation步骤&#34;&gt;使用animation步骤&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;声明关键帧@keyframes&lt;/li&gt;
&lt;li&gt;添加动画animation&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;keyframes语法&#34;&gt;@keyframes语法&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;from to&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;@keyframes slidein {
from {
    transform: translateX(0%);
}
to {
    transform: translateX(100%);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;百分数定义&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;@keyframes identifier {
0% { top: 0; left: 0; }
30% { top: 50px; }
68%, 72% { left: 50px; }
100% { top: 100px; left: 100%; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;animation语法&#34;&gt;animation语法&lt;/h4&gt;

&lt;p&gt;&lt;font color=#0099ff&gt;animation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名&lt;/font&gt;&lt;br&gt;
时长：1s或者1000ms&lt;br&gt;
过渡方式：跟transition取值一样，如linear&lt;br&gt;
次数：3或者2.4或者infinite&lt;br&gt;
方向：reverse|alternate|alternate-reverse&lt;br&gt;
填充模式：none|forwards|backwards|both&lt;br&gt;
是否暂停：paused|running&lt;br&gt;
以上所有属性都有对应的单独属性&lt;br&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction&#34;&gt;渲染树构建、布局及绘制&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/rendering/&#34;&gt;渲染性能&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count&#34;&gt;坚持仅合成器的属性和管理层计数&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://csstriggers.com/&#34;&gt;CSS Triggers&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Tue, 03 Sep 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</guid>
      
        <description>

&lt;h2 id=&#34;一-url-包含哪几部分-每部分分别有什么作用&#34;&gt;一 URL 包含哪几部分，每部分分别有什么作用&lt;/h2&gt;

&lt;h4 id=&#34;url全称-uniform-resource-locator-统一资源定位符&#34;&gt;url全称 Uniform Resource Locator 统一资源定位符&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;协议 http/https&lt;/li&gt;
&lt;li&gt;域名 www.so.com&lt;/li&gt;
&lt;li&gt;服务器路径 /s&lt;/li&gt;
&lt;li&gt;查询参数 wd=hello&amp;amp;rsv_spt=1&lt;/li&gt;
&lt;li&gt;锚点 #5 与浏览器页面有关&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;二-dns-的作用是什么-nslookup命令怎么用&#34;&gt;二 DNS 的作用是什么，nslookup命令怎么用&lt;/h2&gt;

&lt;h4 id=&#34;dns全称domain-name-system-域名系统&#34;&gt;DNS全称Domain Name System 域名系统&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;当输入xiedaimala.com, 浏览器回向电信/联通提供的DNS服务器询问xiedaimala.com的对应IP&lt;/li&gt;
&lt;li&gt;电信/联通会回答一个IP&lt;/li&gt;
&lt;li&gt;浏览器向对应IP的80/443端口发送请求&lt;/li&gt;
&lt;li&gt;请求内容是查看xiedaimala.com的首页&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;nslookup命令用于查询dns的记录-查看域名解析是否正常-在网络故障的时候用来诊断网络问题&#34;&gt;nslookup命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题。&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;nslookup baidu.com&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DNS request timed out.
    timeout was 2 seconds.
服务器:  UnKnown
Address:  4.2.2.1

非权威应答:
名称:    baidu.com
Addresses:  220.181.38.148
          39.156.69.79
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nslookup domain [dns-server]&lt;/code&gt;
- 查询一个域名的A记录&lt;/p&gt;

&lt;h2 id=&#34;三-ip的作用是什么-ping命令怎么用&#34;&gt;三 IP的作用是什么，ping命令怎么用&lt;/h2&gt;

&lt;p&gt;只要在互联网中，就会有至少一个ip&lt;br&gt;
ip分为内网ip和外网ip&lt;br&gt;
路由器连上电信的服务器就会被分配一个外网ip,如果重启路由器可能被重新分配一个外网ip&lt;br&gt;
路由器会给自己分配一个好记的内网IP,比如192.168.1.1&lt;br&gt;
路由器会在一定范围内创建一个内网,给内网中的每一个设备分配一个不同的内网IP&lt;br&gt;
一般来说格式是192.168.xxx.xxx,比如192.168.1.2&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;ping命令&#34;&gt;ping命令&lt;/h4&gt;

&lt;p&gt;ping 命令有助于验证网络层的连通性！一般进行网络故障排除时，可以使用ping 命令向目标计算机或IP地址发送ICMP回显请求，目标计算机会返回回显应答，如果目标计算机不能返回回显应答，说明在源计算机和目标计算机之间的网路存在问题，需要进一步检查解决！&lt;br&gt;
ping 命令是Windows 操作系统中集成的一个TCP/IP协议探测工具，它只能在有TCP/IP协议有网络中使用。&lt;br&gt;
ping 命令的格式为：ping[参数1][参数2][……][目的地址]&lt;br&gt;
如果不知道ping命令有那些参数的话，只要在命令提示符中键入ping命令，就能得到。&lt;br&gt;
一般使用只需要在命令行输入ping baidu.com即可等待输出连通性测试。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;正在 Ping baidu.com [220.181.38.148] 具有 32 字节的数据:&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=78ms TTL=46&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=63ms TTL=46&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=61ms TTL=46&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=62ms TTL=46&lt;br&gt;&lt;/p&gt;

&lt;p&gt;220.181.38.148 的 Ping 统计信息:&lt;br&gt;
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，&lt;br&gt;
往返行程的估计时间(以毫秒为单位):&lt;br&gt;
    最短 = 61ms，最长 = 78ms，平均 = 66ms&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;四-域名是什么-分别哪几类域名&#34;&gt;四 域名是什么，分别哪几类域名&lt;/h2&gt;

&lt;h4 id=&#34;域名就是对ip的别称&#34;&gt;域名就是对IP的别称&lt;/h4&gt;

&lt;p&gt;一个域名可以对应不同IP,称为负载均衡,防止一台机器扛不住&lt;br&gt;
一个IP可以对应不同域名,称为共享主机,一般没钱就会这样做&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;域名分为顶级域名-二级域名-三级域名&#34;&gt;域名分为顶级域名 二级域名 三级域名&lt;/h4&gt;

&lt;p&gt;com 顶级域名&lt;br&gt;
xiedaimala.com 二级域名&lt;br&gt;
www.xiedaimala.com 三级域名&lt;br&gt;
他们是父子关系&lt;br&gt;
www是多余的吗?是的，非常多余:)&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML常用标签</title>
      <link>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Wed, 28 Aug 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      
        <description>

&lt;h2 id=&#34;一-a-标签的用法&#34;&gt;一 a 标签的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;属性 1：href(hyper reference) 超级引用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;取值：网址（&lt;a href=&#34;https://xx.com&#34;&gt;https://xx.com&lt;/a&gt;, &lt;a href=&#34;http://xx.com&#34;&gt;http://xx.com&lt;/a&gt;, //xx.com）&lt;/li&gt;
&lt;li&gt;路径: /a/b/c 根目录, 也就是服务器的根目录。 a/b 相对路径，等于 ./a/b&lt;/li&gt;
&lt;li&gt;伪协议：&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:alert(1);&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:;&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;//没有动作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;//页面刷新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;//回到页面顶部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;baidu&amp;quot; target=&amp;quot;xxx&amp;quot;&amp;gt;baidu&amp;lt;/a&amp;gt;&lt;/code&gt;//打开一个window.name为xxx的窗口，若没有就新建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;mailto:m.bluth@example.com&amp;quot;&amp;gt;Email&amp;lt;/a&amp;gt;&lt;/code&gt;//邮件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;tel:+123456789&amp;quot;&amp;gt;Phone&amp;lt;/a&amp;gt;&lt;/code&gt;//电话&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;属性 2：target（决定跳转的链接在哪里打开）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;取值：_self 当前页面加载，即当前的响应到同一HTML 4 frame（或HTML5浏览上下文）。此值是默认的，如果没有指定属性的话。&lt;/li&gt;
&lt;li&gt;_blank 新窗口打开，即到一个新的未命名的HTML4窗口或HTML5浏览器上下文&lt;/li&gt;
&lt;li&gt;_top HTML5中：加载响应进入顶层浏览上下文, 如果没有parent框架或者浏览上下文，此选项的行为方式相同_self&lt;/li&gt;
&lt;li&gt;_parent 加载响应到当前框架的HTML4父框架或当前的HTML5浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式与 _self 相同。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-img-标签的用法&#34;&gt;二 img 标签的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作用是发起 get 请求，展示图片

&lt;ul&gt;
&lt;li&gt;属性 1：alt(图片加载失败的时的提示文字)&lt;/li&gt;
&lt;li&gt;属性 2：src(source)(图片路径)&lt;/li&gt;
&lt;li&gt;属性 3：height(高度)&lt;/li&gt;
&lt;li&gt;属性 4：width(宽度)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;三-table-标签的用法&#34;&gt;三 table 标签的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常用的标签（table、thead、tbody、tfoot、th、tr、td）

&lt;ul&gt;
&lt;li&gt;注意的样式 1：table-layout&lt;/li&gt;
&lt;li&gt;注意的样式 2：border-collapse（决定是否合并 collapse(合并) | separate（分开））&lt;/li&gt;
&lt;li&gt;注意的样式 3：border-spacing（每个 td 之间的间隙）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;img max-width: 100%;&lt;/li&gt;
&lt;li&gt;form 发get或者post请求，然后刷新页面&lt;/li&gt;

&lt;li&gt;&lt;p&gt;input和button&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;xxx&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;strong&amp;gt;xxx&amp;lt;/strong&amp;gt;
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;button标签里还可以嵌套其他标签，input不行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表单中&lt;code&gt;&amp;lt;button type=&amp;quot;&amp;quot;&amp;gt;xxx&amp;lt;/button&amp;gt;&lt;/code&gt;默认type=&amp;ldquo;submit&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单选和复选框使用相同name属性表示一组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot; /&amp;gt;

&amp;lt;input type=&amp;quot;file&amp;quot; multiple /&amp;gt; //选择多个文件
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;textarea&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;textarea style=&amp;quot;resize: none; width: 50%; height: 300px&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//禁止拖动大小&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>html 入门笔记 1</title>
      <link>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Tue, 27 Aug 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      
        <description>

&lt;h2 id=&#34;一-html-是谁发明的&#34;&gt;一 HTML 是谁发明的&lt;/h2&gt;

&lt;p&gt;蒂姆·伯纳斯-李(简称李爵士) 大佬毕竟是大佬：）&lt;/p&gt;

&lt;h2 id=&#34;二-html-起手应该写什么&#34;&gt;二 HTML 起手应该写什么&lt;/h2&gt;

&lt;p&gt;利用编辑器 emmet 插件使用 ！+ tab 自动生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt; //声明文档类型为html,而不是svg/xml
&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt; //声明语言类型，翻译参考
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt; //文件的字符编码
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt; //兼容手机
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt; //告诉IE使用最新内核
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; //网页标题
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-常用的表示章节的标签&#34;&gt;三 常用的表示章节的标签&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;header(头部)
定义文章的介绍信息：标题，logo，slogan；包裹目录部分，搜索框，一个 nav 或者任何相关的 logo；
一个页面中&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;的个数没有限制，可以为每个内容块添加一个 header；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;h1-h6(数字越小字体越大)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;section(章、节)
与 article 的差别在于，它是整体的一部分，或者是文章的一节，一般来说 section 也会带有标题；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;article(文章)
定义文档中可以脱离其他部分的，一份独立的内容，通常带有标题，当 article 内嵌 article 时，里外层的内容应该是相关的，比如一篇微博和它的评论；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;main(主要的)
定义文章的主要内容
main 标签在一份文档中是唯一的，其后代元素常常包括&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;aside(旁边的)
侧边栏（与 article 并列存在）或者嵌入内容（在 article 内），通常认为是独立拆分出来而不受整体影响的一部分，作为主要内容的附属信息，如索引，词条列表，或者页面及站点的附属信息，如广告，作者资料介绍等；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;p(段落)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;footer(脚部)
页脚，通常包含作者、版权信息或者相关链接等；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;div(划分 块级元素)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;四-全局属性有哪些&#34;&gt;四 全局属性有哪些&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;class (引用 css 以.开头的样式, 尽量能用就用)&lt;/li&gt;
&lt;li&gt;contenteditable(在浏览器可以编辑)&lt;/li&gt;
&lt;li&gt;hidden(隐藏)&lt;/li&gt;
&lt;li&gt;style(内联样式)&lt;/li&gt;
&lt;li&gt;tabindex(增加用户体验多元化) 可以取 1 2 0 -1 ，tab、 shift tab 切换, -1 永远不访问&lt;/li&gt;
&lt;li&gt;title(增加可读性)&lt;/li&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不到万不得已不要用 id，
html 和 css 中出现多个相同 id 的标签同时生效&lt;/p&gt;

&lt;p&gt;id 不能和 window 属性重名，
因为 xxx.style.border 失效，
document.getElementById 有效&lt;/p&gt;

&lt;h2 id=&#34;五-常用的内容标签有哪些-分别是什么意思&#34;&gt;五 常用的内容标签有哪些，分别是什么意思&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;a(anchor 超链接)：用作跳转其他页面&lt;/li&gt;
&lt;li&gt;ol+li(ordered list 有序列表)：带有数字的列表&lt;/li&gt;
&lt;li&gt;ul+li(unordered list 无序列表)：以·开头的列表&lt;/li&gt;
&lt;li&gt;dl+dt+dd(description list 描述列表)&lt;/li&gt;
&lt;li&gt;pre(输出默认格式) html 回车缩成一个空格 tab 缩成一个空格 多个空格缩成一个空格
保留用 pre 标签包裹&lt;/li&gt;
&lt;li&gt;hr(水平线)&lt;/li&gt;
&lt;li&gt;br(回车)&lt;/li&gt;
&lt;li&gt;em(强调语气,以斜体展示)
表达对文本内容的强调；
其强调位置的不同往往带来语义的变化（可以理解为英语口语中针对一句话中不同位置的重度，影响听话人的理解）；
在视觉效果上也是斜体的效果；&lt;/li&gt;
&lt;li&gt;strong(重要强调,以加粗展示)
表示强调带有着重意味，意在传达内容的重要性（需要尽快被看到）、严重性或者紧急性，；&lt;/li&gt;
&lt;li&gt;code(代码标签)&lt;/li&gt;
&lt;li&gt;quote(引用)&lt;/li&gt;
&lt;li&gt;blockquote(独自占一行块引用)&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;适用于在一段文本中突出重点，强调位置的不同往往会影响语义，而如果仅仅在语态或者语气上为了突出某个文本，应该使用&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在使用&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;时，W3C 鼓励开发者最好检查下是否有更合适的标签可替代，例如，上述的&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;，来突出重点，或是&lt;code&gt;&amp;lt;dfn&amp;gt;&lt;/code&gt;，用来定义一个术语；&lt;/li&gt;
&lt;li&gt;如果为了突出文本的重要性，紧急性，严重性应该使用&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;W3C 明确说明，&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签，言外之意，官方并不推荐使用 b 标签&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;相关信息引用：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32570423&#34;&gt;https://zhuanlan.zhihu.com/p/32570423&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>大吉</title>
      <link>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Mon, 26 Aug 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      
        <description>&lt;p&gt;(=^-^=)/&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
