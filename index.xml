<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jane - A super concise theme for Hugo</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 10 Dec 2019 19:34:36 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>闭包和执行上下文</title>
      <link>http://localhost:1313/post/%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Tue, 10 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      
        <description>

&lt;h2 id=&#34;一-什么是闭包&#34;&gt;一 什么是闭包？&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;1. 用 apply 将数组添加到另一个数组&lt;/font&gt;&lt;br&gt;
闭包翻译自英文单词closure，这是个不太好翻译的词。编译原理中，它是处理语法产生式的一个步骤；而在编程语言领域，它表示一种函数。&lt;/p&gt;

&lt;p&gt;闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。&lt;/p&gt;

&lt;p&gt;这个古典的闭包定义中，闭包包含两个部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境部分

&lt;ul&gt;
&lt;li&gt;环境&lt;/li&gt;
&lt;li&gt;标识符列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表达式部分&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在JavaScript中找到对应的闭包组成部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境部分

&lt;ul&gt;
&lt;li&gt;环境：函数的词法环境（执行上下文的一部分）&lt;/li&gt;
&lt;li&gt;标识符列表：函数中用到的未声明的变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表达式部分：函数体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。&lt;/p&gt;

&lt;h2 id=&#34;二-闭包的用途是什么&#34;&gt;二 闭包的用途是什么？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function init() {
    var name = &amp;quot;Mozilla&amp;quot;; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数,一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
}
init();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中
将代码封装成一个闭包形式，等待时机成熟的时候再使用，比如实现柯里化和反柯里化&lt;/p&gt;

&lt;h2 id=&#34;三-闭包的缺点是什么&#34;&gt;三 闭包的缺点是什么？&lt;/h2&gt;

&lt;p&gt;IE有bug，IE在我们使用完闭包之后，依然回收不了闭包里面引用的变量。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>apply,call和bind</title>
      <link>http://localhost:1313/post/applycall%E5%92%8Cbind/</link>
      <pubDate>Sat, 07 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/applycall%E5%92%8Cbind/</guid>
      
        <description>

&lt;h2 id=&#34;一-apply&#34;&gt;一 apply&lt;/h2&gt;

&lt;h3 id=&#34;语法&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;func.apply(thisArg, [argsArray])&lt;/p&gt;

&lt;h4 id=&#34;参数&#34;&gt;参数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisArg
可选的。在 func 函数运行时使用的 this 值。
（注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;argsArray
可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。
如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。
(从ECMAScript 5 开始可以使用类数组对象。)&lt;/p&gt;

&lt;h4 id=&#34;返回值&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;调用这个指定this值(thisArg)和参数([argsArray])的函数(func)
调用函数的结果即它的返回值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// expected output: 2

//结果
//&amp;gt; 7
//&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;1. 用 apply 将数组添加到另一个数组&lt;/font&gt;&lt;br&gt;
我们可以使用push将元素追加到数组中。并且，因为push接受可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，在这种情况下，concat确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组。在这种情况下我们可以使用apply&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var array = [&#39;a&#39;, &#39;b&#39;];
var elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, 0, 1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;2. 使用apply和内置函数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/* 找出数组中最大/小的数字 */
var numbers = [5, 6, 2, 3, 7];

/* 应用(apply) Math.min/Math.max 内置函数完成 */
var max = Math.max.apply(null, numbers); /* 基本等同于 Math.max(numbers[0], ...) 或 Math.max(5, 6, ..) */
var min = Math.min.apply(null, numbers);

/* 代码对比： 用简单循环完成 */
max = -Infinity, min = +Infinity;

for (var i = 0; i &amp;lt; numbers.length; i++) {
  if (numbers[i] &amp;gt; max)
    max = numbers[i];
  if (numbers[i] &amp;lt; min) 
    min = numbers[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当心：如果用上面的方式调用apply，会有超出JavaScript引擎的参数长度限制的风险。当你对一个方法传入非常多的参数（比如一万个）时，就非常有可能会导致越界问题, 这个临界值是根据不同的 JavaScript 引擎而定的（JavaScript 核心中已经做了硬编码  参数个数限制在65536），因为这个限制（实际上也是任何用到超大栈空间的行为的自然表现）是未指定的. 有些引擎会抛出异常。更糟糕的是其他引擎会直接限制传入到方法的参数个数，导致参数丢失。举个例子：如果某个引擎限制了方法参数最多为4个（实际真正的参数个数限制当然要高得多了, 这里只是打个比方）, 上面的代码中, 真正通过 apply传到目标方法中的参数为 5, 6, 2, 3 而不是完整的数组。&lt;/p&gt;

&lt;p&gt;如果你的参数数组可能非常大，那么推荐使用下面这种策略来处理：将参数数组切块后循环传入目标方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function minOfArray(arr) {
  let min = Infinity;
  // let QUANTUM = 32768;
  let QUANTUM = 2;

  for (let i = 0, len = arr.length; i &amp;lt; len; i += QUANTUM) {
    //防止越界
    let rightIndex = Math.min(i + QUANTUM, len);
    let origin = arr.slice(i, rightIndex);
    let submin = Math.min.apply(null, origin);
    min = Math.min(submin, min);
  }

  return min;
}

let min = minOfArray([5, 6, 2, 3, 7]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;3. 使用apply来链接构造器&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;你可以使用apply来链接一个对象构造器，类似于Java。在接下来的例子中我们会创建一个全局Function 对象的construct方法 ，来使你能够在构造器中使用一个类数组对象而非参数列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Function.prototype.construct = function (aArgs) {
  var oNew = Object.create(this.prototype);
  this.apply(oNew, aArgs);
  return oNew;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-call&#34;&gt;二 call&lt;/h2&gt;

&lt;h3 id=&#34;语法-1&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;function.call(thisArg, arg1, arg2, &amp;hellip;)&lt;/p&gt;

&lt;h4 id=&#34;参数-1&#34;&gt;参数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisArg
可选的。在 func 函数运行时使用的 this 值。
（注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arg1, arg2, &amp;hellip;
指定的参数列表。&lt;/p&gt;

&lt;h4 id=&#34;返回值-1&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;使用调用者提供的 this 值(thisArg)和参数(arg1, arg2, &amp;hellip;)调用该函数(function)
调用函数的结果即它的返回值。
若该方法没有返回值，则返回 undefined。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// expected output: 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结果
&amp;gt; 7
&amp;gt; 2&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用父构造函数&lt;br&gt;
在一个子构造函数中，你可以通过调用父构造函数的 call 方法来实现继承，类似于 Java 中的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Product(name, price) {
this.name = name;
this.price = price;
}

function Food(name, price) {
Product.call(this, name, price);
this.category = &#39;food&#39;;
}

function Toy(name, price) {
Product.call(this, name, price);
this.category = &#39;toy&#39;;
}

var cheese = new Food(&#39;feta&#39;, 5);
var fun = new Toy(&#39;robot&#39;, 40);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用 Food 和 Toy 构造函数创建的对象实例都会拥有在 Product 构造函数中添加的 name 属性和 price 属性,但 category 属性是在各自的构造函数中定义的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用匿名函数
在下例中的 for 循环体内，我们创建了一个匿名函数，然后通过调用该函数的 call 方法，将每个数组元素作为指定的 this 值执行了那个匿名函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var animals = [
{ species: &#39;Lion&#39;, name: &#39;King&#39; },
{ species: &#39;Whale&#39;, name: &#39;Fail&#39; }
];

for (var i = 0; i &amp;lt; animals.length; i++) {
(function(i) {
this.print = function() {
  console.log(&#39;#&#39; + i + &#39; &#39; + this.species
              + &#39;: &#39; + this.name);
}
this.print();
}).call(animals[i], i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个匿名函数的主要目的是给每个数组元素对象添加一个 print 方法，这个 print 方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为 this 值传入那个匿名函数（普通参数就可以），目的是为了演示 call 的用法。
3. 使用 call 方法调用函数并且指定上下文的 &amp;lsquo;this&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function greet() {
  var reply = [this.animal, &#39;typically sleep between&#39;, this.sleepDuration].join(&#39; &#39;);
  console.log(reply);
}

var obj = {
  animal: &#39;cats&#39;, 
  sleepDuration: &#39;12 and 16 hours&#39;
};

greet.call(obj);  // cats typically sleep between 12 and 16 hours
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用 greet 方法的时候，该方法的this值会绑定到 obj 对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用函数并且不指定第一个参数（argument）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var sData = &#39;Wisen&#39;;

function display() {
console.log(&#39;sData value is %s &#39;, this.sData);
}

display.call();  // sData value is Wisen
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们调用了 display 方法，但并没有传递它的第一个参数。如果没有传递第一个参数，this 的值将会被绑定为全局对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&#39;use strict&#39;;

var sData = &#39;Wisen&#39;;

function display() {
  console.log(&#39;sData value is %s &#39;, this.sData);
}

display.call(); // Cannot read the property of &#39;sData&#39; of undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在严格模式下，this 的值将会是 undefined&lt;/p&gt;

&lt;h2 id=&#34;三-bind&#34;&gt;三 bind&lt;/h2&gt;

&lt;p&gt;bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
}

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语法-2&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;function.bind(thisArg[, arg1[, arg2[, &amp;hellip;]]])&lt;/p&gt;

&lt;h4 id=&#34;参数-2&#34;&gt;参数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;thisArg
调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。&lt;/li&gt;
&lt;li&gt;arg1, arg2, &amp;hellip;
当目标函数被调用时，被预置入绑定函数的参数列表中的参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;返回值-2&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。&lt;/p&gt;

&lt;h3 id=&#34;示例-2&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;#F5B041&#34;&gt;1. 创建绑定函数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;this.x = 9;    // 在浏览器中，this 指向全局的 &amp;quot;window&amp;quot; 对象
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回 9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#F5B041&#34;&gt;2. 预设初始参数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function list() {
  return Array.prototype.slice.call(arguments);
}

function addArguments(arg1, arg2) {
    return arg1 + arg2
}

var list1 = list(1, 2, 3); // [1, 2, 3]

var result1 = addArguments(1, 2); // 3

// 创建一个函数，它拥有预设参数列表。
var leadingThirtysevenList = list.bind(null, 37);

// 创建一个函数，它拥有预设的第一个参数
var addThirtySeven = addArguments.bind(null, 37); 

var list2 = leadingThirtysevenList(); 
// [37]

var list3 = leadingThirtysevenList(1, 2, 3); 
// [37, 1, 2, 3]

var result2 = addThirtySeven(5); 
// 37 + 5 = 42 

var result3 = addThirtySeven(5, 10);
// 37 + 5 = 42 ，第二个参数被忽略
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>jQuery设计思想</title>
      <link>http://localhost:1313/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</link>
      <pubDate>Sun, 10 Nov 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</guid>
      
        <description>

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作。&lt;br&gt;
这是它区别于其他Javascript库的根本特点。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-jquery如何获取元素&#34;&gt;一 jQuery如何获取元素&lt;/h2&gt;

&lt;p&gt;使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。
选择表达式可以是CSS选择器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/css-selector.png&#34; alt=&#34;css-selector&#34; /&gt;&lt;/p&gt;

&lt;p&gt;也可以是&lt;a href=&#34;(https://www.jquery123.com/category/selectors/)&#34;&gt;jQuery特有的表达式&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;a:first&#39;) //选择网页中第一个a元素

$(&#39;tr:odd&#39;) //选择表格的奇数行

$(&#39;#myForm :input&#39;) // 选择表单中的input元素

$(&#39;div:visible&#39;) //选择可见的div元素

$(&#39;div:gt(2)&#39;) // 选择所有的div元素，除了前三个

$(&#39;div:animated&#39;) // 选择当前处于动画状态的div元素
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-jquery的链式操作是怎样的&#34;&gt;二 jQuery的链式操作是怎样的&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来。比如：&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;　$(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;Hello&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分解开来，就是下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;div&#39;) //找到div元素
  .find(&#39;h3&#39;) //选择其中的h3元素
  .eq(2) //选择第3个h3元素
  .html(&#39;Hello&#39;); //将它的内容改为Hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，
这个jQuery对象中就包括了那些可以对选中元素做一些操作的函数
所以不同操作可以连在一起。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;jQuery还提供了.end()方法，使得结果集可以后退一步：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/end.png&#34; alt=&#34;end&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-jquery如何创建元素&#34;&gt;三 jQuery如何创建元素&lt;/h2&gt;

&lt;p&gt;创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&#39;);

$(&#39;&amp;lt;li class=&amp;quot;new&amp;quot;&amp;gt;new list item&amp;lt;/li&amp;gt;&#39;);

$(&#39;ul&#39;).append(&#39;&amp;lt;li&amp;gt;list item&amp;lt;/li&amp;gt;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制元素使用.clone()。&lt;/p&gt;

&lt;p&gt;删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。&lt;/p&gt;

&lt;p&gt;清空元素内容（但是不删除该元素）使用.empty()。&lt;/p&gt;

&lt;h2 id=&#34;四-jquery如何移动元素&#34;&gt;四 jQuery如何移动元素&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;假定我们选中了一个div元素，需要把它移动到p元素后面。&lt;/p&gt;

&lt;p&gt;第一种方法是使用.insertAfter()，把div元素移动p元素后面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;div&#39;).insertAfter($(&#39;p&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种方法是使用.after()，把p元素加到div元素前面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;p&#39;).after($(&#39;div&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。&lt;/p&gt;

&lt;p&gt;使用这种模式的操作方法，一共有四对：
&lt;img src=&#34;http://localhost:1313/images/move.png&#34; alt=&#34;move&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-jquery如何修改元素的属性&#34;&gt;五 jQuery如何修改元素的属性&lt;/h2&gt;

&lt;p&gt;操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即&amp;rdquo;取值器&amp;rdquo;与&amp;rdquo;赋值器&amp;rdquo;合一。到底是取值还是赋值，由函数的参数决定。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(&#39;h1&#39;).html(); //html()没有参数，表示取出h1的值

$(&#39;h1&#39;).html(&#39;Hello&#39;); //html()有参数Hello，表示对h1进行赋值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常见的取值和赋值函数如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/change.png&#34; alt=&#34;change&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html&#34;&gt;jQuery设计思想-阮一峰&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS函数的执行时机</title>
      <link>http://localhost:1313/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Sat, 26 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      
        <description>

&lt;h2 id=&#34;一-为什么如下代码会打印-6-个-6&#34;&gt;一 为什么如下代码会打印 6 个 6&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let i = 0
for(i = 0; i &amp;lt; 6; i++){
  setTimeout(()=&amp;gt;{
    console.log(i)
  },0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当setTimeout()的毫秒数设置为0的时候，是要先执行完函数调用栈中的代码，然后立即调用定时器。&lt;/p&gt;

&lt;p&gt;因为定时器都被放在了一个队列中，等待上下文的可执行代码运行完毕后，才开始运行定时器，也就是定时器才刚开始计时。代码中声明一个let全局变量i，然后在for循环中改变i，所以在定时器的方法执行的时候，变量i已经变成了6，所以输出的全部是6。&lt;/p&gt;

&lt;h2 id=&#34;二-让上面代码打印-0-1-2-3-4-5-的方法&#34;&gt;二 让上面代码打印 0、1、2、3、4、5 的方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;for(let i = 0; i &amp;lt; 6; i++){
  setTimeout(() =&amp;gt; {
    console.log(i)
  }, 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout1.png&#34; alt=&#34;setTimeout1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;利用ES6 let命令声明变量块级作用域的概念，和前面for循环使用全局变量i不同，当前的i只在本轮循环有效， 所以每一次循环的i其实都是一个新的变量，所以5个setTimeout回调函数虽然都引用了变量i,但实际上这5个i是独立的，仅在自己的块级作用域内有效&lt;/p&gt;

&lt;h2 id=&#34;三-除了使用-for-let-配合-还有什么其他方法可以打印出-0-1-2-3-4-5&#34;&gt;三 除了使用 for let 配合，还有什么其他方法可以打印出 0、1、2、3、4、5&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let i
for (i = 0; i &amp;lt; 6; i++) {
  // j = i
  !(function(j) { 
    setTimeout(() =&amp;gt; {
      console.log(j)
    }, 0);
  })(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout2.png&#34; alt=&#34;setTimeout2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过立即执行函数创造了n个不同的函数作用域，给setTimeout传入n个不同的参数，所以就可以打印出0、1、2、3、4、5
此外，我们还可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let output = function(i) {
  setTimeout(function() {
    console.log(i);
  }, 0);
};
let i
for (i = 0; i &amp;lt; 6; i++) {
  output.call(undefined, i); // 这里传过去的 i 值被复制，而不是引用
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout3.png&#34; alt=&#34;setTimeout3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原理和上面相似，也是创造了n个不同的函数作用域，给setTimeout传入了n个不同的参数&lt;/p&gt;

&lt;p&gt;此外我们还可以利用setTimeout第三个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let i
for (i = 0; i &amp;lt; 6; i++) {
  setTimeout(function(i) {
    console.log(i);
  }, 0, i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/setTimeout4.png&#34; alt=&#34;setTimeout4&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS排序算法</title>
      <link>http://localhost:1313/post/js%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-选择排序&#34;&gt;一 选择排序&lt;/h2&gt;

&lt;p&gt;选择排序 即在当前区间选出一个最小值和区间第一个数交换位置，区间大小减一&lt;br&gt;
一共有n个数， 第一次遍历n个数，第二次遍历n-1个数，以此类推，&lt;br&gt;
共遍历 n + (n - 1) + (n - 2) + &amp;hellip; + (n - n + 1) + (n - n) 次 (加0不影响最终结果)&lt;br&gt;
例如   数组一共有5个数，遍历 5 + 4 + 3 + 2 + 1 + 0 次&lt;br&gt;
也可以写作 n + &amp;hellip; + 3 + 2 + 1 + 0 = (n * (n + 1)) / 2 = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;(n^2) + (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)n &lt;br&gt;
时间复杂度O(n^2)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const log = console.log.bind(console)

//求当前区间内最小值下标
let minIndex = (numbers) =&amp;gt; {
  let index = 0
  for(let i = 1; i &amp;lt; numbers.length; i++){
    if(numbers[i] &amp;lt; numbers[index]){
      index = i
    }
  }
  return index
}

let swap = (array, i, j) =&amp;gt; {
  let temp = array[i]
  array[i] = array[j]
  array[j] = temp
}

let sort = (numbers) =&amp;gt; {
  //遍历到区间只剩下两个数就可以停止了, 也就是i等于numbers.length - 2
  //如8个数 i等于numbers.length - 2 = 6, 区间是arr[6]-arr[7] 没有arr[8] :)
  for(let i = 0; i &amp;lt; numbers.length - 1; i++){
    log(`------`)
    log(`i: ${i}`)
    //求当前区间内的最小值在整个数组内的下标
    //为当前区间内的最小值的下标 加 区间前面的数字个数
    //例如 [6,2,4,5]  1 + 0
    //再比如 6,[2,4,5] 0 + 1
    let index = minIndex(numbers.slice(i)) + i
    log(`index: ${index}`)
    log(`min: ${numbers[index]}`)
    if(index!==i){
      swap(numbers, index, i)
      log(`swap ${index}:${i}`)
      log(numbers)
    }
  }
  return numbers
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-快速排序&#34;&gt;二 快速排序&lt;/h2&gt;

&lt;p&gt;快速排序,即取数组中间位置的数，比它小的数放在它的左边，比它大的放在右边
然后区间变为它的左边的数组成的数组 和 它的右边的数组成的数组
最后区间只剩一个数终止&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let quickSort = arr =&amp;gt; {
  if (arr.length &amp;lt;= 1) { 
    return arr; 
  }
  let pivotIndex = Math.floor(arr.length / 2);
  let pivot = arr.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i &amp;lt; arr.length; i++){
    if (arr[i] &amp;lt; pivot) { 
      left.push(arr[i])
    } else { 
      right.push(arr[i]) 
    }
  }
  return quickSort(left).concat([pivot], quickSort(right))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-归并排序&#34;&gt;三 归并排序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let merge = (a, b) =&amp;gt; {
  if (a.length === 0) {
    return b
  }
  if (b.length === 0) {
    return a
  }
  return a[0] &amp;gt; b[0] ?
    [b[0]].concat(merge(a, b.slice(1))) :
    [a[0]].concat(merge(a.slice(1), b))
}

let mergeSort = arr =&amp;gt; {
  let k = arr.length
  if (k === 1) { 
    return arr
  }
  let left = arr.slice(0, Math.floor(k / 2))
  let right = arr.slice(Math.floor(k / 2))
  return merge(mergeSort(left), mergeSort(right))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-计数排序&#34;&gt;四 计数排序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let countSort = arr =&amp;gt; {
  let hashTable = {}, max = 0, result = []
  for(let i = 0; i &amp;lt; arr.length; i++){ 
    if(!(arr[i] in hashTable)){ 
      hashTable[arr[i]] = 1
    }else{
      hashTable[arr[i]] += 1
    }
    if(max &amp;lt; arr[i]) {
      max = arr[i]
    }
  }
  for(let j = 0; j &amp;lt;= max; j++){ 
    if(j in hashTable){
      for(let i = 0; i &amp;lt; hashTable[j]; i++){
        result.push(j)
      }
    }
  }
  return result
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间不够，待更新&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS对象基本用法</title>
      <link>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sun, 20 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-声明对象的两种语法&#34;&gt;一 声明对象的两种语法&lt;/h2&gt;

&lt;h3 id=&#34;对象的定义&#34;&gt;对象的定义&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;无序的数据集合&lt;/font&gt;&lt;br&gt;
&lt;font color=&#34;orange&#34;&gt;键值对的集合&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;对象的写法&#34;&gt;对象的写法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;let obj = {&#39;name&#39;: &#39;zwx&#39;, &#39;age&#39;: 18, }&lt;/code&gt;
&lt;code&gt;let obj = new Object({&#39;name&#39;: &#39;zwx&#39;})&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;细节&#34;&gt;细节&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;键名是字符串，可以包含任意Unicode字符&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;如果书写键名时省略引号，就只能按标识符规则书写&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;‘省略引号’也改变不了‘键名是个字符串’这个事实&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-如何删除对象的属性&#34;&gt;二 如何删除对象的属性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;delete obj.xxx&lt;/code&gt;或者&lt;code&gt;delete obj[&#39;xxx&#39;]&lt;/code&gt;
&lt;font color=&#34;orange&#34;&gt;即可删除obj的xxx属性&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;不含属性名&lt;/font&gt;
&lt;code&gt;&#39;xxx&#39; in obj === false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;含有属性名，但是值为undefined&lt;/font&gt;
&lt;code&gt;&#39;xxx&#39; in obj &amp;amp;&amp;amp; obj.xxx === undefined&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-如何查看对象的属性&#34;&gt;三 如何查看对象的属性&lt;/h2&gt;

&lt;h3 id=&#34;查看所有属性&#34;&gt;查看所有属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;查看自身所有属性&lt;/font&gt;
&lt;code&gt;Object.keys(obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;查看自身+共有属性&lt;/font&gt;
&lt;code&gt;console.dir(obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;判断一个属性是自身的还是共有的&lt;/font&gt;
&lt;code&gt;obj.hasOwnProperty(&#39;toString&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看属性&#34;&gt;查看属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;中括号语法：&lt;/font&gt;
&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt;
&lt;font color=&#34;orange&#34;&gt;点语法：&lt;/font&gt;
&lt;code&gt;obj.key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;优先使用&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt;&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;重点&#34;&gt;重点&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;obj.name 等价于 obj[&amp;lsquo;name&amp;rsquo;]&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let my = function(){
let list = [&#39;name&#39;, &#39;age&#39;, &#39;gender&#39;]
let person = {
  name: &#39;zwx&#39;,
  age: 18,
  gender: &#39;male&#39;,
}
for (let i = 0; i &amp;lt; list.length; i++) {
  let name = list[i]
  //person.name 等价于 person[&#39;name&#39;]
  console.log(&#39;1.&#39; + person.name)
  console.log(&#39;2.&#39; + person[name])
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/查看对象属性.png&#34; alt=&#34;查看对象属性&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;四-如何修改或增加对象的属性&#34;&gt;四 如何修改或增加对象的属性&lt;/h2&gt;

&lt;h3 id=&#34;修改或增加属性&#34;&gt;修改或增加属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;直接赋值&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;let obj = {name: &#39;zwx&#39;} // name是字符串&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj.name = &#39;zwx&#39; // name是字符串&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj[&#39;name&#39;] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj[&#39;na&#39; + &#39;me&#39;] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;let key = &#39;name&#39;; obj[key] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;批量赋值&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.assign(obj, {age: 18, gender: &#39;male&#39;})&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;修改或增加共有属性&#34;&gt;修改或增加共有属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;无法通过其中一个对象修改或增加他们的共有属性&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let obj = {}, obj2 = {} // 共有原型上的toString&lt;/code&gt;&lt;br&gt;
&lt;code&gt;obj.toString = &#39;xxx&#39;&lt;/code&gt; 只会修改自身的属性&lt;br&gt;
&lt;code&gt;obj2.toString&lt;/code&gt; 还是原型上的方法&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;我偏要修改或增加原型上的属性&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;obj.__proto__.toString = &#39;xxx&#39; // 不推荐用__proto__&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Object.prototype.toString = &#39;xxx&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;一般来说，不要修改原型，会引起很多问题&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-name-in-obj和obj-hasownproperty-name-的区别&#34;&gt;五 &amp;lsquo;name&amp;rsquo; in obj和obj.hasOwnProperty(&amp;lsquo;name&amp;rsquo;)的区别&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;prop in object&lt;/code&gt; 检查它（或其原型链）是否包含具有指定名称的属性&lt;/p&gt;

&lt;p&gt;in右操作数必须是一个对象值。&lt;/p&gt;

&lt;p&gt;如果使用 delete 运算符删除了一个属性，则 in 运算符对所删除属性返回 false。&lt;/p&gt;

&lt;p&gt;如果你只是将一个属性的值赋值为undefined，而没有删除它，则 in 运算仍然会返回true。&lt;/p&gt;

&lt;p&gt;如果一个属性是从原型链上继承来的，in 运算符也会返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;obj.hasOwnProperty(&#39;name&#39;)&lt;/code&gt; 方法会返回一个布尔值，指示对象自身属性中（非继承属性）是否具有指定的属性，
如果 object 具有带指定名称的属性，则 hasOwnProperty 方法返回 true，否则返回 false。此方法不会检查对象原型链中的属性；该属性必须是对象本身的一个成员。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let father = {money: 9999}
let son = Object.create(father)
son.name = &#39;son&#39;
console.log(&#39;1.检查它（或其原型链）是否包含具有指定名称的属性&#39;)
console.log(&#39;money&#39; in son) //true
console.log(&#39;2.对象自身属性中（非继承属性）是否具有指定的属性&#39;)
console.log(son.hasOwnProperty(&#39;money&#39;)) //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/方法区别.png&#34; alt=&#34;方法区别&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS的基本语法</title>
      <link>http://localhost:1313/post/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-表达式和语句&#34;&gt;一 表达式和语句&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句（statement）是为了完成某种任务而进行的操作&lt;/font&gt;，比如下面就是一行赋值语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let a = 1 + 3;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这条语句先用&lt;code&gt;let&lt;/code&gt;命令，声明了变量&lt;code&gt;a&lt;/code&gt;，然后将&lt;code&gt;1 + 3&lt;/code&gt;的运算结果赋值给变量&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + 3&lt;/code&gt;叫做表达式（expression）&lt;/p&gt;

&lt;p&gt;表达式指一个为了得到返回值的计算式。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；
表达式则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。
比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let a = 1 + 3 ; let b = &#39;abc&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;;;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的代码就表示3个空语句。&lt;/p&gt;

&lt;p&gt;表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + 3;&lt;/code&gt;
&lt;code&gt;&#39;abc&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面两行语句只是单纯地产生一个值，并没有任何实际的意义。&lt;/p&gt;

&lt;h2 id=&#34;二-标识符的规则&#34;&gt;二 标识符的规则&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;标识符（identifier）指的是用来识别各种值的合法名称。&lt;/font&gt;最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;A&lt;/code&gt;是两个不同的标识符。&lt;/p&gt;

&lt;p&gt;标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript引擎遇到非法标识符，就会报错。&lt;/p&gt;

&lt;p&gt;简单说，标识符命名规则如下。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（&lt;code&gt;$&lt;/code&gt;）和下划线（&lt;code&gt;_&lt;/code&gt;）。
第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;。&lt;/font&gt;
下面这些都是合法的标识符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arg0&lt;/code&gt;
&lt;code&gt;_tmp&lt;/code&gt;
&lt;code&gt;$elem&lt;/code&gt;
&lt;code&gt;π&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面这些则是不合法的标识符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;1a  // 第一个字符不能是数字
23  // 同上
***  // 标识符不能包含星号
a+b  // 标识符不能包含加号
-d  // 标识符不能包含减号或连词线
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文是合法的标识符，可以用作变量名。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var 临时变量 = 1;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-if-else-条件语句&#34;&gt;三 if else 条件语句&lt;/h2&gt;

&lt;p&gt;if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，&lt;code&gt;true&lt;/code&gt;表示真，&lt;code&gt;false&lt;/code&gt;表示伪&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (布尔值)
  语句;

// 或者
if (布尔值) 语句;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3)
  m = m + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，只有在&lt;code&gt;m&lt;/code&gt;等于&lt;code&gt;3&lt;/code&gt;时，才会将其值加上&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3) {
  m += 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议总是在if语句中使用大括号，因为这样方便插入语句。&lt;/p&gt;

&lt;p&gt;注意，if后面的表达式之中，不要混淆赋值表达式（&lt;code&gt;=&lt;/code&gt;）、严格相等运算符（&lt;code&gt;===&lt;/code&gt;）和相等运算符（&lt;code&gt;==&lt;/code&gt;）。尤其是赋值表达式不具有比较作用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 1;
var y = 2;
if (x = y) {
  console.log(x);
}
// &amp;quot;2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的原意是，当&lt;code&gt;x&lt;/code&gt;等于&lt;code&gt;y&lt;/code&gt;的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将&lt;code&gt;y&lt;/code&gt;赋值给变量&lt;code&gt;x&lt;/code&gt;，再判断变量&lt;code&gt;x&lt;/code&gt;的值（等于&lt;code&gt;2&lt;/code&gt;）的布尔值（结果为&lt;code&gt;true&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (x = 2) { // 不报错
if (2 = x) { // 报错
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;代码块后面，还可以跟一个&lt;code&gt;else&lt;/code&gt;代码块，表示不满足条件时，所要执行的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3) {
  // 满足条件时，执行的语句
} else {
  // 不满足条件时，执行的语句
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码判断变量&lt;code&gt;m&lt;/code&gt;是否等于&lt;code&gt;3&lt;/code&gt;，如果等于就执行&lt;code&gt;if&lt;/code&gt;代码块，否则执行&lt;code&gt;else&lt;/code&gt;代码块。&lt;/p&gt;

&lt;p&gt;对同一个变量进行多次判断时，多个&lt;code&gt;if...else&lt;/code&gt;语句可以连写在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 0) {
  // ...
} else if (m === 1) {
  // ...
} else if (m === 2) {
  // ...
} else {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;else&lt;/code&gt;代码块总是与离自己最近的那个&lt;code&gt;if&lt;/code&gt;语句配对。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var m = 1;
var n = 2;

if (m !== 1)
if (n === 2) console.log(&#39;hello&#39;);
else console.log(&#39;world&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码不会有任何输出，&lt;code&gt;else&lt;/code&gt;代码块不会得到执行，因为它跟着的是最近的那个&lt;code&gt;if&lt;/code&gt;语句，相当于下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m !== 1) {
  if (n === 2) {
    console.log(&#39;hello&#39;);
  } else {
    console.log(&#39;world&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想让&lt;code&gt;else&lt;/code&gt;代码块跟随最上面的那个if语句，就要改变大括号的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m !== 1) {
  if (n === 2) {
    console.log(&#39;hello&#39;);
  }
} else {
  console.log(&#39;world&#39;);
}
// world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-while-for-循环语句&#34;&gt;四 while for 循环语句&lt;/h2&gt;

&lt;h3 id=&#34;while语句&#34;&gt;While语句&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;While&lt;/code&gt;语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (条件)
  语句;

// 或者
while (条件) 语句;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;while&lt;/code&gt;语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (条件) {
  语句;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是&lt;code&gt;while&lt;/code&gt;语句的一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while (i &amp;lt; 100) {
  console.log(&#39;i 当前为：&#39; + i);
  i = i + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将循环100次，直到i等于100为止。&lt;/p&gt;

&lt;p&gt;下面的例子是一个无限循环，因为循环条件总是为真。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (true) {
  console.log(&#39;Hello, world&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for语句&#34;&gt;for语句&lt;/h3&gt;

&lt;p&gt;for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (初始化表达式; 条件; 递增表达式)
  语句

// 或者

for (初始化表达式; 条件; 递增表达式) {
  语句
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;for语句后面的括号里面，有三个表达式。&lt;/font&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;初始化表达式（initialize）&lt;/font&gt;：确定循环变量的初始值，只在循环开始时执行一次。&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;条件表达式（test）&lt;/font&gt;：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;递增表达式（increment）&lt;/font&gt;：每轮循环的最后一个操作，通常用来递增循环变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 3;
for (var i = 0; i &amp;lt; x; i++) {
  console.log(i);
}
// 0
// 1
// 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，初始化表达式是&lt;code&gt;var i = 0&lt;/code&gt;，即初始化一个变量&lt;code&gt;i&lt;/code&gt;；测试表达式是&lt;code&gt;i &amp;lt; x&lt;/code&gt;，即只要&lt;code&gt;i&lt;/code&gt;小于&lt;code&gt;x&lt;/code&gt;，就会执行循环；递增表达式是&lt;code&gt;i++&lt;/code&gt;，即每次循环结束后，&lt;code&gt;i&lt;/code&gt;增大&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所有&lt;code&gt;for&lt;/code&gt;循环，都可以改写成&lt;code&gt;while&lt;/code&gt;循环。上面的例子改为&lt;code&gt;while&lt;/code&gt;循环，代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 3;
var i = 0;

while (i &amp;lt; x) {
  console.log(i);
  i++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for ( ; ; ){
  console.log(&#39;Hello World&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。&lt;/p&gt;

&lt;h2 id=&#34;五-break-continue-语句&#34;&gt;五 break continue 语句&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句用于跳出代码块或循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while(i &amp;lt; 100) {
  console.log(&#39;i 当前为：&#39; + i);
  i++;
  if (i === 10) break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码只会执行10次循环，一旦i等于10，就会跳出循环。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;循环也可以使用&lt;code&gt;break&lt;/code&gt;语句跳出循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (var i = 0; i &amp;lt; 5; i++) {
  console.log(i);
  if (i === 3)
    break;
}
// 0
// 1
// 2
// 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码执行到&lt;code&gt;i&lt;/code&gt;等于&lt;code&gt;3&lt;/code&gt;，就会跳出循环。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while (i &amp;lt; 100){
  i++;
  if (i % 2 === 0) continue;
  console.log(&#39;i 当前为：&#39; + i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码只有在&lt;code&gt;i&lt;/code&gt;为奇数时，才会输出&lt;code&gt;i&lt;/code&gt;的值。如果&lt;code&gt;i&lt;/code&gt;为偶数，则直接进入下一轮循环。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;如果存在多重循环，不带参数的&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都只针对最内层循环。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;六-标签-label&#34;&gt;六 标签（label）&lt;/h2&gt;

&lt;p&gt;JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;label:
  语句
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。&lt;/p&gt;

&lt;p&gt;标签通常与&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句配合使用，跳出特定的循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) break top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为一个双重循环区块，&lt;code&gt;break&lt;/code&gt;命令后面加上了&lt;code&gt;top&lt;/code&gt;标签（注意，&lt;code&gt;top&lt;/code&gt;不用加引号），满足条件时，直接跳出双层循环。如果&lt;code&gt;break&lt;/code&gt;语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p&gt;

&lt;p&gt;标签也可以用于跳出代码块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;foo: {
  console.log(1);
  break foo;
  console.log(&#39;本行不会输出&#39;);
}
console.log(2);
// 1
// 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码执行到&lt;code&gt;break foo&lt;/code&gt;，就会跳出区块。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句也可以与标签配合使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) continue top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
// i=2, j=0
// i=2, j=1
// i=2, j=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;continue&lt;/code&gt;命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果&lt;code&gt;continue&lt;/code&gt;语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;面试相关题：&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//label
{
    top: x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://wangdoc.com/javascript/index.html&#34;&gt;网道JavaScript 教程&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Javascript的诞生</title>
      <link>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
      <pubDate>Sat, 21 Sep 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
      
        <description>

&lt;h2 id=&#34;一-javascript的诞生&#34;&gt;一 Javascript的诞生&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。&lt;/p&gt;

&lt;p&gt;网景公司当时有两个选择：一个是采用现有的语言，比如Perl、Python、Tcl、Scheme等等，允许它们直接嵌入网页；另一个是发明一种全新的语言。就在这时，发生了另外一件大事：1995年Sun公司将Oak语言改名为Java，正式向市场推出。Sun公司大肆宣传，许诺这种语言可以&amp;rdquo;一次编写，到处运行&amp;rdquo;（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。网景公司动了心，决定与Sun公司结成联盟。它不仅允许Java程序以applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。&lt;/p&gt;

&lt;p&gt;总之，当时的形势就是，网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。因此，Javascript后来就是网景和Sun两家公司一起携手推向市场的，这种语言被命名为&amp;rdquo;Java+script&amp;rdquo;并不是偶然的。&lt;/p&gt;

&lt;p&gt;此时，34岁的系统程序员Brendan Eich登场了。1995年4月，网景公司录用了他。一个月之后，1995年5月，网景公司做出决策，未来的网页脚本语言必须&amp;rdquo;看上去与Java足够相似&amp;rdquo;，但是比Java简单，使得非专业的网页作者也能很快上手。这个决策实际上将Perl、Python、Tcl、Scheme等非面向对象编程的语言都排除在外了。而Brendan Eich被指定为这种&amp;rdquo;简化版Java语言&amp;rdquo;的设计师。&lt;/p&gt;

&lt;p&gt;但是，他对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。总的来说，他的设计思路是这样的：&lt;br&gt;
1.借鉴C语言的基本语法；&lt;br&gt;
2.借鉴Java语言的数据类型和内存管理；&lt;br&gt;
3.借鉴Scheme语言，将函数提升到&amp;rdquo;第一等公民&amp;rdquo;（first class）的地位；&lt;br&gt;
4.借鉴Self语言，使用基于原型（prototype）的继承机制。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;如果不是公司的决策，Brendan Eich绝不可能把Java作为Javascript设计的原型。作为设计者，他一点也不喜欢自己的这个作品：&amp;rdquo;与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：&amp;rsquo;它的优秀之处并非原创，它的原创之处并不优秀。&amp;rsquo;（the part that is good is not original, and the part that is original is not good.）&amp;rdquo;&lt;br&gt;
所以，最后，Javascript语言实际上是两种语言风格的混合产物&amp;mdash;-（简化的）函数式编程+（简化的）面向对象编程。&lt;/p&gt;

&lt;h2 id=&#34;二-javascript的设计缺陷&#34;&gt;二 Javascript的设计缺陷&lt;/h2&gt;

&lt;p&gt;Javascript的设计，其实只用了十天。而且，设计师是为了向公司交差，本人并不愿意这样设计（参见《Javascript诞生记》）。&lt;/p&gt;

&lt;p&gt;另一方面，这种语言的设计初衷，是为了解决一些简单的网页互动（比如，检查&amp;rdquo;用户名&amp;rdquo;是否填写），并没有考虑复杂应用的需要。设计者做梦也想不到，Javascript将来可以写出像Gmail这种极其庞大复杂的网页。
Javascript同时结合了函数式编程和面向对象编程的特点，这很可能是历史上的第一例。而且直到今天为止，Javascript仍然是世界上唯一使用Prototype继承模型的主要语言。这使得它没有设计先例可以参考。
Javascript的发展非常快，根本没有时间调整设计。&lt;/p&gt;

&lt;p&gt;1995年5月，设计方案定稿；10月，解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。Javascript缺乏一个从小到大、慢慢积累用户的过程，而是连续的爆炸式扩散增长。大量的既成网页和业余网页设计者的参与，使得调整语言规格困难重重。&lt;/p&gt;

&lt;p&gt;更糟的是，Javascript的规格还没来及调整就固化了。&lt;/p&gt;

&lt;p&gt;1996年8月，微软公司强势介入，宣布推出自己的脚本语言Jscript；11月，为了压制微软，网景公司决定申请Javascript的国际标准；1997年6月，第一个国际标准ECMA-262正式颁布。&lt;/p&gt;

&lt;p&gt;也就是说，Javascript推出一年半之后，国际标准就问世了。设计缺陷还没有充分暴露就成了标准。相比之下，C语言问世将近20年之后，国际标准才颁布。&lt;/p&gt;

&lt;p&gt;Javascript的全局变量，在所有模块中都是可见的；任何一个函数内部都可以生成全局变量，这大大加剧了程序的复杂性。&lt;/p&gt;

&lt;p&gt;==用来判断两个值是否相等。当两个值类型不同时，会发生自动转换，得到的结果非常不符合直觉。
因此，推荐任何时候都使用&amp;rdquo;===&amp;ldquo;（精确判断）比较符。&lt;/p&gt;

&lt;p&gt;既然Javascript有缺陷，数量还不少，那么它是不是一种很糟糕的语言？有没有前途？&lt;/p&gt;

&lt;p&gt;回答是Javascript并不算糟糕，相反它的编程能力很强大，前途很光明。&lt;/p&gt;

&lt;p&gt;首先，如果遵守良好的编程规范，加上第三方函数库的帮助，Javascript的这些缺陷大部分可以回避。&lt;/p&gt;

&lt;p&gt;其次，Javascript目前是网页编程的唯一语言，只要互联网继续发展，它就必然一起发展。目前，许多新项目大大扩展了它的用途，node.js使得Javascript可以用于后端的服务器编程，coffeeScript使你可以用python和ruby的语法，撰写Javascript。&lt;/p&gt;

&lt;p&gt;最后，只要发布新版本的语言标准（比如 ECMAscript 5），就可以弥补这些设计缺陷。当然，标准的发布和标准的实现是两回事，上述的很多缺陷也许会一直伴随到Javascript存在的最后一天。&lt;/p&gt;

&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html&#34;&gt;Javascript诞生记&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html&#34;&gt;Javascript的10个设计缺陷&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://baike.baidu.com/item/javascript&#34;&gt;javascript&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 15 Sep 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>

&lt;h2 id=&#34;一-浏览器渲染过程&#34;&gt;一 浏览器渲染过程&lt;/h2&gt;

&lt;h4 id=&#34;概览步骤&#34;&gt;概览步骤&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;根据HTML构建HTML树（DOM）&lt;/li&gt;
&lt;li&gt;根据CSS构建CSS树（CSSOM）&lt;/li&gt;
&lt;li&gt;将两棵树合并成一颗渲染树（render tree）&lt;/li&gt;
&lt;li&gt;Layout布局（文档流、盒模型、计算大小和位置）&lt;/li&gt;
&lt;li&gt;Paint绘制（把边框颜色、文字颜色、阴影等画出来）&lt;/li&gt;
&lt;li&gt;Composite合成（根据层叠关系展示画面）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;三颗树图示&#34;&gt;三颗树图示&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/三颗树.png&#34; alt=&#34;三棵树&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;三种更新方式&#34;&gt;三种更新方式&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;第一种，全部步骤&lt;br&gt;
div.remove()会触发当前元素消失，其他元素re-layout&lt;br&gt;&lt;/li&gt;
&lt;li&gt;第二种，跳过layout&lt;br&gt;
改变背景颜色，直接repaint+composite&lt;br&gt;&lt;/li&gt;
&lt;li&gt;第三种，跳过layout和paint&lt;br&gt;
改变transform，只需composite&lt;br&gt;
注意！必须全屏查看效果，在iframe里看有问题&lt;br&gt;
图示如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/三种更新方式.png&#34; alt=&#34;三种更新方式&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-css属性之transition-过渡&#34;&gt;二 CSS属性之transition-过渡&lt;/h2&gt;

&lt;h4 id=&#34;transition作用-补充中间帧&#34;&gt;transition作用&amp;ndash;补充中间帧&lt;/h4&gt;

&lt;h4 id=&#34;transition语法如下&#34;&gt;transition语法如下&lt;/h4&gt;

&lt;p&gt;&lt;font color=#0099ff&gt;transition: 属性名 时长 过渡方式 延迟&lt;/font&gt;&lt;br&gt;
transition: left 200ms linear&lt;br&gt;
可以用逗号分隔两个不同属性&lt;br&gt;
transtion: left 200ms, top 400ms&lt;br&gt;
可以用all代表所有属性&lt;br&gt;
transition: all 200ms&lt;br&gt;
过渡方式有: linear|ease|ease-in|ease-out|ease-in-out&lt;br&gt;
cubic-bezier|step-start|step-end|steps&lt;br&gt;
具体细节参考数学相关&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=#FF7F50&gt;注意！并不是所有属性都能过渡&lt;/font&gt;&lt;br&gt;
display:none =&amp;gt; block没办法过渡&lt;br&gt;
一般改为visibility: hidden =&amp;gt; visible&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=#0099ff&gt;过渡必须要有起始&lt;/font&gt;&lt;br&gt;
一般只有一次动画，或者两次&lt;br&gt;
比如hover和非hover状态的过渡&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-css属性之animation-动画&#34;&gt;三 CSS属性之animation-动画&lt;/h2&gt;

&lt;h4 id=&#34;使用animation步骤&#34;&gt;使用animation步骤&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;声明关键帧@keyframes&lt;/li&gt;
&lt;li&gt;添加动画animation&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;keyframes语法&#34;&gt;@keyframes语法&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;from to&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;@keyframes slidein {
from {
    transform: translateX(0%);
}
to {
    transform: translateX(100%);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;百分数定义&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;@keyframes identifier {
0% { top: 0; left: 0; }
30% { top: 50px; }
68%, 72% { left: 50px; }
100% { top: 100px; left: 100%; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;animation语法&#34;&gt;animation语法&lt;/h4&gt;

&lt;p&gt;&lt;font color=#0099ff&gt;animation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名&lt;/font&gt;&lt;br&gt;
时长：1s或者1000ms&lt;br&gt;
过渡方式：跟transition取值一样，如linear&lt;br&gt;
次数：3或者2.4或者infinite&lt;br&gt;
方向：reverse|alternate|alternate-reverse&lt;br&gt;
填充模式：none|forwards|backwards|both&lt;br&gt;
是否暂停：paused|running&lt;br&gt;
以上所有属性都有对应的单独属性&lt;br&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction&#34;&gt;渲染树构建、布局及绘制&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/rendering/&#34;&gt;渲染性能&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count&#34;&gt;坚持仅合成器的属性和管理层计数&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://csstriggers.com/&#34;&gt;CSS Triggers&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Tue, 03 Sep 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</guid>
      
        <description>

&lt;h2 id=&#34;一-url-包含哪几部分-每部分分别有什么作用&#34;&gt;一 URL 包含哪几部分，每部分分别有什么作用&lt;/h2&gt;

&lt;h4 id=&#34;url全称-uniform-resource-locator-统一资源定位符&#34;&gt;url全称 Uniform Resource Locator 统一资源定位符&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;协议 http/https&lt;/li&gt;
&lt;li&gt;域名 www.so.com&lt;/li&gt;
&lt;li&gt;服务器路径 /s&lt;/li&gt;
&lt;li&gt;查询参数 wd=hello&amp;amp;rsv_spt=1&lt;/li&gt;
&lt;li&gt;锚点 #5 与浏览器页面有关&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;二-dns-的作用是什么-nslookup命令怎么用&#34;&gt;二 DNS 的作用是什么，nslookup命令怎么用&lt;/h2&gt;

&lt;h4 id=&#34;dns全称domain-name-system-域名系统&#34;&gt;DNS全称Domain Name System 域名系统&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;当输入xiedaimala.com, 浏览器回向电信/联通提供的DNS服务器询问xiedaimala.com的对应IP&lt;/li&gt;
&lt;li&gt;电信/联通会回答一个IP&lt;/li&gt;
&lt;li&gt;浏览器向对应IP的80/443端口发送请求&lt;/li&gt;
&lt;li&gt;请求内容是查看xiedaimala.com的首页&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;nslookup命令用于查询dns的记录-查看域名解析是否正常-在网络故障的时候用来诊断网络问题&#34;&gt;nslookup命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题。&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;nslookup baidu.com&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DNS request timed out.
    timeout was 2 seconds.
服务器:  UnKnown
Address:  4.2.2.1

非权威应答:
名称:    baidu.com
Addresses:  220.181.38.148
          39.156.69.79
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nslookup domain [dns-server]&lt;/code&gt;
- 查询一个域名的A记录&lt;/p&gt;

&lt;h2 id=&#34;三-ip的作用是什么-ping命令怎么用&#34;&gt;三 IP的作用是什么，ping命令怎么用&lt;/h2&gt;

&lt;p&gt;只要在互联网中，就会有至少一个ip&lt;br&gt;
ip分为内网ip和外网ip&lt;br&gt;
路由器连上电信的服务器就会被分配一个外网ip,如果重启路由器可能被重新分配一个外网ip&lt;br&gt;
路由器会给自己分配一个好记的内网IP,比如192.168.1.1&lt;br&gt;
路由器会在一定范围内创建一个内网,给内网中的每一个设备分配一个不同的内网IP&lt;br&gt;
一般来说格式是192.168.xxx.xxx,比如192.168.1.2&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;ping命令&#34;&gt;ping命令&lt;/h4&gt;

&lt;p&gt;ping 命令有助于验证网络层的连通性！一般进行网络故障排除时，可以使用ping 命令向目标计算机或IP地址发送ICMP回显请求，目标计算机会返回回显应答，如果目标计算机不能返回回显应答，说明在源计算机和目标计算机之间的网路存在问题，需要进一步检查解决！&lt;br&gt;
ping 命令是Windows 操作系统中集成的一个TCP/IP协议探测工具，它只能在有TCP/IP协议有网络中使用。&lt;br&gt;
ping 命令的格式为：ping[参数1][参数2][……][目的地址]&lt;br&gt;
如果不知道ping命令有那些参数的话，只要在命令提示符中键入ping命令，就能得到。&lt;br&gt;
一般使用只需要在命令行输入ping baidu.com即可等待输出连通性测试。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;正在 Ping baidu.com [220.181.38.148] 具有 32 字节的数据:&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=78ms TTL=46&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=63ms TTL=46&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=61ms TTL=46&lt;br&gt;
来自 220.181.38.148 的回复: 字节=32 时间=62ms TTL=46&lt;br&gt;&lt;/p&gt;

&lt;p&gt;220.181.38.148 的 Ping 统计信息:&lt;br&gt;
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，&lt;br&gt;
往返行程的估计时间(以毫秒为单位):&lt;br&gt;
    最短 = 61ms，最长 = 78ms，平均 = 66ms&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;四-域名是什么-分别哪几类域名&#34;&gt;四 域名是什么，分别哪几类域名&lt;/h2&gt;

&lt;h4 id=&#34;域名就是对ip的别称&#34;&gt;域名就是对IP的别称&lt;/h4&gt;

&lt;p&gt;一个域名可以对应不同IP,称为负载均衡,防止一台机器扛不住&lt;br&gt;
一个IP可以对应不同域名,称为共享主机,一般没钱就会这样做&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;域名分为顶级域名-二级域名-三级域名&#34;&gt;域名分为顶级域名 二级域名 三级域名&lt;/h4&gt;

&lt;p&gt;com 顶级域名&lt;br&gt;
xiedaimala.com 二级域名&lt;br&gt;
www.xiedaimala.com 三级域名&lt;br&gt;
他们是父子关系&lt;br&gt;
www是多余的吗?是的，非常多余:)&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML常用标签</title>
      <link>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Wed, 28 Aug 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      
        <description>

&lt;h2 id=&#34;一-a-标签的用法&#34;&gt;一 a 标签的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;属性 1：href(hyper reference) 超级引用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;取值：网址（&lt;a href=&#34;https://xx.com&#34;&gt;https://xx.com&lt;/a&gt;, &lt;a href=&#34;http://xx.com&#34;&gt;http://xx.com&lt;/a&gt;, //xx.com）&lt;/li&gt;
&lt;li&gt;路径: /a/b/c 根目录, 也就是服务器的根目录。 a/b 相对路径，等于 ./a/b&lt;/li&gt;
&lt;li&gt;伪协议：&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:alert(1);&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:;&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;//没有动作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;//页面刷新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;xxx&amp;lt;/a&amp;gt;&lt;/code&gt;//回到页面顶部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;baidu&amp;quot; target=&amp;quot;xxx&amp;quot;&amp;gt;baidu&amp;lt;/a&amp;gt;&lt;/code&gt;//打开一个window.name为xxx的窗口，若没有就新建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;mailto:m.bluth@example.com&amp;quot;&amp;gt;Email&amp;lt;/a&amp;gt;&lt;/code&gt;//邮件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;tel:+123456789&amp;quot;&amp;gt;Phone&amp;lt;/a&amp;gt;&lt;/code&gt;//电话&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;属性 2：target（决定跳转的链接在哪里打开）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;取值：_self 当前页面加载，即当前的响应到同一HTML 4 frame（或HTML5浏览上下文）。此值是默认的，如果没有指定属性的话。&lt;/li&gt;
&lt;li&gt;_blank 新窗口打开，即到一个新的未命名的HTML4窗口或HTML5浏览器上下文&lt;/li&gt;
&lt;li&gt;_top HTML5中：加载响应进入顶层浏览上下文, 如果没有parent框架或者浏览上下文，此选项的行为方式相同_self&lt;/li&gt;
&lt;li&gt;_parent 加载响应到当前框架的HTML4父框架或当前的HTML5浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式与 _self 相同。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-img-标签的用法&#34;&gt;二 img 标签的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作用是发起 get 请求，展示图片

&lt;ul&gt;
&lt;li&gt;属性 1：alt(图片加载失败的时的提示文字)&lt;/li&gt;
&lt;li&gt;属性 2：src(source)(图片路径)&lt;/li&gt;
&lt;li&gt;属性 3：height(高度)&lt;/li&gt;
&lt;li&gt;属性 4：width(宽度)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;三-table-标签的用法&#34;&gt;三 table 标签的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常用的标签（table、thead、tbody、tfoot、th、tr、td）

&lt;ul&gt;
&lt;li&gt;注意的样式 1：table-layout&lt;/li&gt;
&lt;li&gt;注意的样式 2：border-collapse（决定是否合并 collapse(合并) | separate（分开））&lt;/li&gt;
&lt;li&gt;注意的样式 3：border-spacing（每个 td 之间的间隙）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;img max-width: 100%;&lt;/li&gt;
&lt;li&gt;form 发get或者post请求，然后刷新页面&lt;/li&gt;

&lt;li&gt;&lt;p&gt;input和button&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;xxx&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;strong&amp;gt;xxx&amp;lt;/strong&amp;gt;
&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;button标签里还可以嵌套其他标签，input不行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表单中&lt;code&gt;&amp;lt;button type=&amp;quot;&amp;quot;&amp;gt;xxx&amp;lt;/button&amp;gt;&lt;/code&gt;默认type=&amp;ldquo;submit&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单选和复选框使用相同name属性表示一组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot; /&amp;gt;

&amp;lt;input type=&amp;quot;file&amp;quot; multiple /&amp;gt; //选择多个文件
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;textarea&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;textarea style=&amp;quot;resize: none; width: 50%; height: 300px&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//禁止拖动大小&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>html 入门笔记 1</title>
      <link>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Tue, 27 Aug 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      
        <description>

&lt;h2 id=&#34;一-html-是谁发明的&#34;&gt;一 HTML 是谁发明的&lt;/h2&gt;

&lt;p&gt;蒂姆·伯纳斯-李(简称李爵士) 大佬毕竟是大佬：）&lt;/p&gt;

&lt;h2 id=&#34;二-html-起手应该写什么&#34;&gt;二 HTML 起手应该写什么&lt;/h2&gt;

&lt;p&gt;利用编辑器 emmet 插件使用 ！+ tab 自动生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt; //声明文档类型为html,而不是svg/xml
&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt; //声明语言类型，翻译参考
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt; //文件的字符编码
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt; //兼容手机
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt; //告诉IE使用最新内核
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; //网页标题
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-常用的表示章节的标签&#34;&gt;三 常用的表示章节的标签&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;header(头部)
定义文章的介绍信息：标题，logo，slogan；包裹目录部分，搜索框，一个 nav 或者任何相关的 logo；
一个页面中&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;的个数没有限制，可以为每个内容块添加一个 header；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;h1-h6(数字越小字体越大)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;section(章、节)
与 article 的差别在于，它是整体的一部分，或者是文章的一节，一般来说 section 也会带有标题；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;article(文章)
定义文档中可以脱离其他部分的，一份独立的内容，通常带有标题，当 article 内嵌 article 时，里外层的内容应该是相关的，比如一篇微博和它的评论；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;main(主要的)
定义文章的主要内容
main 标签在一份文档中是唯一的，其后代元素常常包括&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;aside(旁边的)
侧边栏（与 article 并列存在）或者嵌入内容（在 article 内），通常认为是独立拆分出来而不受整体影响的一部分，作为主要内容的附属信息，如索引，词条列表，或者页面及站点的附属信息，如广告，作者资料介绍等；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;p(段落)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;footer(脚部)
页脚，通常包含作者、版权信息或者相关链接等；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;div(划分 块级元素)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;四-全局属性有哪些&#34;&gt;四 全局属性有哪些&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;class (引用 css 以.开头的样式, 尽量能用就用)&lt;/li&gt;
&lt;li&gt;contenteditable(在浏览器可以编辑)&lt;/li&gt;
&lt;li&gt;hidden(隐藏)&lt;/li&gt;
&lt;li&gt;style(内联样式)&lt;/li&gt;
&lt;li&gt;tabindex(增加用户体验多元化) 可以取 1 2 0 -1 ，tab、 shift tab 切换, -1 永远不访问&lt;/li&gt;
&lt;li&gt;title(增加可读性)&lt;/li&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不到万不得已不要用 id，
html 和 css 中出现多个相同 id 的标签同时生效&lt;/p&gt;

&lt;p&gt;id 不能和 window 属性重名，
因为 xxx.style.border 失效，
document.getElementById 有效&lt;/p&gt;

&lt;h2 id=&#34;五-常用的内容标签有哪些-分别是什么意思&#34;&gt;五 常用的内容标签有哪些，分别是什么意思&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;a(anchor 超链接)：用作跳转其他页面&lt;/li&gt;
&lt;li&gt;ol+li(ordered list 有序列表)：带有数字的列表&lt;/li&gt;
&lt;li&gt;ul+li(unordered list 无序列表)：以·开头的列表&lt;/li&gt;
&lt;li&gt;dl+dt+dd(description list 描述列表)&lt;/li&gt;
&lt;li&gt;pre(输出默认格式) html 回车缩成一个空格 tab 缩成一个空格 多个空格缩成一个空格
保留用 pre 标签包裹&lt;/li&gt;
&lt;li&gt;hr(水平线)&lt;/li&gt;
&lt;li&gt;br(回车)&lt;/li&gt;
&lt;li&gt;em(强调语气,以斜体展示)
表达对文本内容的强调；
其强调位置的不同往往带来语义的变化（可以理解为英语口语中针对一句话中不同位置的重度，影响听话人的理解）；
在视觉效果上也是斜体的效果；&lt;/li&gt;
&lt;li&gt;strong(重要强调,以加粗展示)
表示强调带有着重意味，意在传达内容的重要性（需要尽快被看到）、严重性或者紧急性，；&lt;/li&gt;
&lt;li&gt;code(代码标签)&lt;/li&gt;
&lt;li&gt;quote(引用)&lt;/li&gt;
&lt;li&gt;blockquote(独自占一行块引用)&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;适用于在一段文本中突出重点，强调位置的不同往往会影响语义，而如果仅仅在语态或者语气上为了突出某个文本，应该使用&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在使用&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;时，W3C 鼓励开发者最好检查下是否有更合适的标签可替代，例如，上述的&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;，来突出重点，或是&lt;code&gt;&amp;lt;dfn&amp;gt;&lt;/code&gt;，用来定义一个术语；&lt;/li&gt;
&lt;li&gt;如果为了突出文本的重要性，紧急性，严重性应该使用&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;W3C 明确说明，&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 元素应当是在其他标签都不合适的情况下最后一个考虑使用的标签，言外之意，官方并不推荐使用 b 标签&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;相关信息引用：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32570423&#34;&gt;https://zhuanlan.zhihu.com/p/32570423&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何用 hugo 搭建个人博客</title>
      <link>http://localhost:1313/post/%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 26 Aug 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>

&lt;h1 id=&#34;如何用-hugo-搭建个人博客&#34;&gt;如何用 hugo 搭建个人博客&lt;/h1&gt;

&lt;h2 id=&#34;为什么我们选择-hugo&#34;&gt;为什么我们选择 Hugo&lt;/h2&gt;

&lt;p&gt;Hugo 是 go 语言实现的一个博客生成器，是世界上最快的博客生成器。JS 实现的博客生成器叫做 Hexo,但是非常难用，在学习过程中呢，工具不是重点，因为我们终将去尝试多种工具：）&lt;/p&gt;

&lt;h2 id=&#34;一-下载并安装-hugo&#34;&gt;一 下载并安装 Hugo&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;前置条件 FQ 并且安装 chrome 插件 &lt;a href=&#34;https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif&#34;&gt;Proxy SwitchyOmega&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github 下载 &lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;Hugo 安装包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;把 Hugo 解压并添加到 Path, 启动 cmder,运行 hugo version 查看版本。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;二-构建-hugo-项目&#34;&gt;二 构建 Hugo 项目&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;进入 Hugo 官网，点击 quick start， follow her heart&lt;/li&gt;
&lt;li&gt;命令行输入&lt;code&gt;hugo new site xxx.github.io-creator&lt;/code&gt;新建 Hugo 项目&lt;/li&gt;
&lt;li&gt;命令行输入&lt;code&gt;git init&lt;/code&gt;初始化 git&lt;/li&gt;
&lt;li&gt;命令行输入&lt;code&gt;git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke&lt;/code&gt;添加 ananke 博客主题&lt;/li&gt;
&lt;li&gt;一般在 post 文件夹下添加 markdown 文件，也就是我们的博客&lt;/li&gt;
&lt;li&gt;命令行输入&lt;code&gt;hugo server -D&lt;/code&gt;启动 Hugo 服务器，浏览器进入&lt;code&gt;http://localhost:1313/&lt;/code&gt;查看效果&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;三-上传-github&#34;&gt;三 上传 github&lt;/h2&gt;

&lt;p&gt;1.命令行输入&lt;code&gt;hugo&lt;/code&gt;生成 public 文件夹，里面已经生成好了我们将要上传的文件&lt;/p&gt;

&lt;p&gt;2.命令行进入 public 文件夹 输入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;
&lt;code&gt;git add .&lt;/code&gt;
&lt;code&gt;git commit -v&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.在 github 上新建 github page，命名 xxx.github.io 4.命令行输入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote add origin git@github.com:xxx/xxx.github.io.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4.将项目 master 分支推到 origin 的 master 分支&lt;/p&gt;

&lt;h2 id=&#34;四-在-github-上绑定域名&#34;&gt;四 在 github 上绑定域名&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;在 namesilo 上购买域名，&lt;/li&gt;
&lt;li&gt;在 github 上填入域名，点击 learn more &lt;img src=&#34;http://localhost:1313/images/1.png&#34; alt=&#34;图片&#34; /&gt;&lt;/li&gt;
&lt;li&gt;下拉，点击 setting up an apex domain &lt;img src=&#34;http://localhost:1313/images/2.png&#34; alt=&#34;图片&#34; /&gt;&lt;/li&gt;
&lt;li&gt;下拉找到 Configuring A records with your DNS provider &lt;img src=&#34;http://localhost:1313/images/3.png&#34; alt=&#34;图片&#34; /&gt;&lt;/li&gt;
&lt;li&gt;将四个 ip 配置到 namesilo&lt;/li&gt;
&lt;li&gt;等待完成：）&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Mon, 26 Aug 2019 13:34:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      
        <description>&lt;p&gt;博客开通啦&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
