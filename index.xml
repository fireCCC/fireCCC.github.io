<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jane - A super concise theme for Hugo</title>
    <link>http://wantsuchen.top/</link>
    <description>Recent content on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 06 Mar 2020 13:34:36 +0800</lastBuildDate>
    
        <atom:link href="http://wantsuchen.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>防抖和节流</title>
      <link>http://wantsuchen.top/post/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</link>
      <pubDate>Fri, 06 Mar 2020 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</guid>
      
        <description>

&lt;p&gt;防抖动是将多次执行变为最后一次执行，
节流是将多次执行变成每隔一段时间执行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @param {function} func 回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @param {number} wait 表示时间窗口的间隔
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @param {boolean} immediate 设置为ture时，是否立即调用函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @return {function} 返回客户调用函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
_.debounce = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(func, wait, immediate) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; timeout, args, context, timestamp, result;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; later = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#228b22&#34;&gt;// 现在和上一次时间戳比较
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; last = _.now() - timestamp;
    &lt;span style=&#34;color:#228b22&#34;&gt;// 如果当前间隔时间少于设定时间且大于0就重新设置定时器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (last &amp;lt; wait &amp;amp;&amp;amp; last &amp;gt;= &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) {
    timeout = setTimeout(later, wait - last);
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#228b22&#34;&gt;// 否则的话就是时间到了执行回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        timeout = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!immediate) {
            result = func.apply(context, args);
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
        }
    }
    };
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
        context = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;;
        args = arguments;
        &lt;span style=&#34;color:#228b22&#34;&gt;// 获得时间戳
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        timestamp = _.now();
        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果定时器不存在且立即执行函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; callNow = immediate &amp;amp;&amp;amp; !timeout;
        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果定时器不存在就创建一个
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!timeout) timeout = setTimeout(later, wait);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (callNow) {
          &lt;span style=&#34;color:#228b22&#34;&gt;// 如果需要立即执行函数的话 通过 apply 执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;          result = func.apply(context, args);
          context = args = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; result;
    };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @param {function} func 回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @param {number} wait 表示时间窗口的间隔
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 如果想忽略结尾函数的调用，传入{trailing: false}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * 两者不能共存，否则函数不能执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; * @return {function} 返回客户调用函数 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt; */&lt;/span&gt;
_.throttle = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(func, wait, options) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; context, args, result;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; timeout = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;// 之前的时间戳
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; previous = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;// 如果 options 没传则设为空对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!options) options = {};
    &lt;span style=&#34;color:#228b22&#34;&gt;// 定时器回调函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; later = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果设置了 leading，就将 previous 设为 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 用于下面函数的第一个 if 判断
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        previous = options.leading === &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt; ? &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; : _.now();
        &lt;span style=&#34;color:#228b22&#34;&gt;// 置空一是为了防止内存泄漏，二是为了下面的定时器判断
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        timeout = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
        result = func.apply(context, args);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    };
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
        &lt;span style=&#34;color:#228b22&#34;&gt;// 获得当前时间戳
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; now = _.now();
        &lt;span style=&#34;color:#228b22&#34;&gt;// 首次进入前者肯定为 true
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果需要第一次不执行函数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 就将上次时间戳设为当前的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 这样在接下来计算 remaining 的值时会大于0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!previous &amp;amp;&amp;amp; options.leading === &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;) previous = now;
        &lt;span style=&#34;color:#228b22&#34;&gt;// 计算剩余时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; remaining = wait - (now - previous);
        context = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;;
        args = arguments;
        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果当前调用已经大于上次调用时间 + wait
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 或者用户手动调了时间
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果设置了 trailing，只会进入这个条件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果没有设置 leading，那么第一次会进入这个条件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 其实还是会进入的，因为定时器的延时
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 并不是准确的时间，很可能你设置了2秒
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;// 但是他需要2.2秒才触发，这时候就会进入这个条件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (remaining &amp;lt;= &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; || remaining &amp;gt; wait) {
        &lt;span style=&#34;color:#228b22&#34;&gt;// 如果存在定时器就清理掉否则会调用二次回调
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (timeout) {
            clearTimeout(timeout);
            timeout = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
        }
        previous = now;
        result = func.apply(context, args);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!timeout &amp;amp;&amp;amp; options.trailing !== &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;) {
            &lt;span style=&#34;color:#228b22&#34;&gt;// 判断是否设置了定时器和 trailing
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// 没有的话就开启一个定时器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// 并且不能不能同时设置 leading 和 trailing
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            timeout = setTimeout(later, remaining);
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; result;
    };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;toc_0&#34;&gt;(=^-^=)/&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title>Vue中的 .sync 修饰符</title>
      <link>http://wantsuchen.top/post/vue%E4%B8%AD%E7%9A%84.sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Wed, 05 Feb 2020 11:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/vue%E4%B8%AD%E7%9A%84.sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      
        <description>

&lt;h3 id=&#34;vue-js官方文档&#34;&gt;Vue.js官方文档&lt;/h3&gt;

&lt;p&gt;在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。&lt;/p&gt;

&lt;p&gt;这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.$emit(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;update:title&amp;#39;&lt;/span&gt;, newTitle)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-document&lt;/span&gt;
  &lt;span style=&#34;color:#658b00&#34;&gt;v-bind:title&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;doc.title&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#658b00&#34;&gt;v-on:update:title&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;doc.title = $event&amp;#34;&lt;/span&gt;
&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-document&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-document&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;v-bind:title&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;sync&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;doc.title&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-document&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-document&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;v-bind&lt;/span&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;sync&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;doc&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;text-document&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样会把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;小例子：&lt;/p&gt;

&lt;p&gt;App.vue&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-vue&#34; data-lang=&#34;vue&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;app&amp;#34;&lt;/span&gt;&amp;gt;
    App.vue 我现在有 {{total}}
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;hr&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Child&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;:money.sync&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;=&amp;#34;total&amp;#34;&lt;/span&gt;/&amp;gt;
    &lt;span style=&#34;color:#228b22&#34;&gt;// &amp;lt;Child :money=&amp;#34;total&amp;#34; v-on:update:money=&amp;#34;total = $event&amp;#34;/&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; Child from &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;./Child.vue&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; {
  data() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; { total: &lt;span style=&#34;color:#b452cd&#34;&gt;10000&lt;/span&gt; };
  },
  components: { Child: Child }
};
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;style&lt;/span&gt;&amp;gt;
.app {
  border: &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;px solid red;
  padding: &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;px;
}
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;style&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Child.vue&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-vue&#34; data-lang=&#34;vue&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;child&amp;#34;&lt;/span&gt;&amp;gt;
    {{money}}
    &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;@&lt;/span&gt;&lt;span style=&#34;color:#658b00&#34;&gt;click&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;$emit(&amp;#39;update:money&amp;#39;, money-100)&amp;#34;&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;span&lt;/span&gt;&amp;gt;花钱&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;span&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;button&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;default&lt;/span&gt; {
  props: [&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;money&amp;#34;&lt;/span&gt;]
};
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;


&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;style&lt;/span&gt;&amp;gt;
.child {
  border: &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;px solid green;
}
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;style&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考链接：&lt;br&gt;
&lt;a href=&#34;https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6&#34;&gt;https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>computed和watch的区别</title>
      <link>http://wantsuchen.top/post/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 03 Feb 2020 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      
        <description>

&lt;h3 id=&#34;computed和watch&#34;&gt;computed和watch&lt;/h3&gt;

&lt;p&gt;computed是计算属性&lt;br&gt;
使用的时候不需要加括号&lt;br&gt;
计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值
即依赖没有发生变化的时候，computed不会重新计算&lt;br&gt;&lt;/p&gt;

&lt;p&gt;watch是侦听器&lt;br&gt;
如果某个属性变化了，就会去执行一个函数&lt;/p&gt;

&lt;p&gt;除了 watch 选项之外，还可以使用命令式的 vm.$watch&lt;br&gt;
Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。如果需要在某个数据变化时做一些事情，使用watch&lt;/p&gt;

&lt;p&gt;示例：
computed&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; vm = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Vue({
  data: { a: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; },
  computed: {
    &lt;span style=&#34;color:#228b22&#34;&gt;// 仅读取
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    aDouble: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; () {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.a * &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
    },
    &lt;span style=&#34;color:#228b22&#34;&gt;// 读取和设置
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    aPlus: {
      get: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; () {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.a + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
      },
      set: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; (v) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.a = v - &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
      }
    }
  }
})
vm.aPlus   &lt;span style=&#34;color:#228b22&#34;&gt;// =&amp;gt; 2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;vm.aPlus = &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
vm.a       &lt;span style=&#34;color:#228b22&#34;&gt;// =&amp;gt; 2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;vm.aDouble &lt;span style=&#34;color:#228b22&#34;&gt;// =&amp;gt; 4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;watch
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;19
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;20
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;21
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;22
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;23
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;24
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;25
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;26
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;27
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;28
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;29
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;30
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;31
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;32
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;33
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;34
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;35
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;36
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;37
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;38
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;39
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;40
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;41
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;42
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;43
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; vm = new &lt;span style=&#34;color:#008b45&#34;&gt;Vue&lt;/span&gt;({
  data: {
    a: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,
    b: &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,
    c: &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,
    d: &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;,
    e: {
      f: {
        g: &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;
      }
    }
  },
  watch: {
    a: &lt;span style=&#34;color:#008b45&#34;&gt;function&lt;/span&gt; (val, oldVal) {
      console.&lt;span style=&#34;color:#008b45&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;new: %s, old: %s&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;, val, oldVal)
    },
    &lt;span style=&#34;color:#228b22&#34;&gt;// 方法名
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    b: &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;someMethod&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#228b22&#34;&gt;// 设置deep: true
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    c: {
      handler: &lt;span style=&#34;color:#008b45&#34;&gt;function&lt;/span&gt; (val, oldVal) { &lt;span style=&#34;color:#228b22&#34;&gt;/* ... */&lt;/span&gt; },
      deep: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
    },
    &lt;span style=&#34;color:#228b22&#34;&gt;// 设置immediate: true
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// 该回调将会在侦听开始之后被立即调用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    d: {
      handler: &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;someMethod&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;,
      immediate: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;
    },
    e: [
      &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;handle1&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;,
      function &lt;span style=&#34;color:#008b45&#34;&gt;handle2&lt;/span&gt; (val, oldVal) { &lt;span style=&#34;color:#228b22&#34;&gt;/* ... */&lt;/span&gt; },
      {
        handler: function &lt;span style=&#34;color:#008b45&#34;&gt;handle3&lt;/span&gt; (val, oldVal) { &lt;span style=&#34;color:#228b22&#34;&gt;/* ... */&lt;/span&gt; },
        &lt;span style=&#34;color:#228b22&#34;&gt;/* ... */&lt;/span&gt;
      }
    ],
    &lt;span style=&#34;color:#228b22&#34;&gt;// watch vm.e.f&amp;#39;s value: {g: 5}
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;e.f&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;&amp;#39;&lt;/span&gt;: &lt;span style=&#34;color:#008b45&#34;&gt;function&lt;/span&gt; (val, oldVal) { &lt;span style=&#34;color:#228b22&#34;&gt;/* ... */&lt;/span&gt; }
  }
})
vm.a = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; // =&amp;gt; new: &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, old: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;参考链接：&lt;br&gt;
&lt;a href=&#34;https://cn.vuejs.org/v2/api/index.html#computed&#34;&gt;https://cn.vuejs.org/v2/api/index.html#computed&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://cn.vuejs.org/v2/guide/computed.html&#34;&gt;https://cn.vuejs.org/v2/guide/computed.html&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Vue数据响应式原理</title>
      <link>http://wantsuchen.top/post/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 22 Jan 2020 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</guid>
      
        <description>

&lt;h3 id=&#34;数据响应式&#34;&gt;数据响应式&lt;/h3&gt;

&lt;p&gt;若一个物体能对外界的刺激做出反应，它就是响应式的。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Vue的data是响应式，即数据响应式&lt;br&gt;
const vm = new Vue({data: {n:0}})&lt;br&gt;
我如果修改vm.n，那么UI中的n就会响应我&lt;br&gt;
Vue2通过Object.defineProperty来实现数据响应式&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#41B883&#34;&gt;当把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。
&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#41B883&#34;&gt;这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;(这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。)&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#41B883&#34;&gt;每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/vue-data-reactive.png&#34; alt=&#34;vue-data-reactive&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;检测变化的注意事项&#34;&gt;检测变化的注意事项&lt;/h3&gt;

&lt;p&gt;受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; vm = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Vue({
  data:{
    a:&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
  }
})

&lt;span style=&#34;color:#228b22&#34;&gt;// `vm.a` 是响应式的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
vm.b = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;// `vm.b` 是非响应式的
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;font color=&#34;#41B883&#34;&gt;对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。&lt;/font&gt;例如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Vue.set(vm.someObject, &#39;b&#39;, 2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this.$set(this.someObject,&#39;b&#39;,2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#41B883&#34;&gt;由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值：&lt;/font&gt;
(Vue会给出一个警告，Vue只会检查第一层属性)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; vm = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Vue({
  data: {
    &lt;span style=&#34;color:#228b22&#34;&gt;// 声明 message 为一个空值字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    message: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
  },
  template: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;lt;div&amp;gt;{{ message }}&amp;lt;/div&amp;gt;&amp;#39;&lt;/span&gt;
})
&lt;span style=&#34;color:#228b22&#34;&gt;// 之后设置 `message`
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;vm.message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Hello!&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问不存在的属性。&lt;/p&gt;

&lt;p&gt;Vue.set和this.$set的作用包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新增key&lt;/li&gt;
&lt;li&gt;自动创建代理和监听（如果没有创建）&lt;/li&gt;
&lt;li&gt;触发UI更新（但是并不会立刻更新）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;font color=&#34;#41B883&#34;&gt;Vue 将被侦听的数组的变异方法(mutation method)进行了包裹，所以它们也将会触发视图更新。&lt;/font&gt;这些被包裹过的方法包括：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;push()
pop()
shift()
unshift()
splice()
sort()
reverse()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ES6&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; VueArray &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Array&lt;/span&gt;{
    push(...args){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; oldLength = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.length
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.push(...args)
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = oldLength; i &amp;lt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.length; i++){
            Vue.set(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, i, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;[i])
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ES5&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; vueArrayPrototype = {
    push: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(){
    log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;something else&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Array&lt;/span&gt;.prototype.push.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;,arguments)
    }
}
vueArrayPrototype._proto_ = &lt;span style=&#34;color:#658b00&#34;&gt;Array&lt;/span&gt;.prototype
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; array = object.create(vueArrayPrototype)
array.push(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考链接：&lt;br&gt;
&lt;a href=&#34;https://cn.vuejs.org/v2/guide/reactivity.html&#34;&gt;https://cn.vuejs.org/v2/guide/reactivity.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B&#34;&gt;https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Vue 两个版本</title>
      <link>http://wantsuchen.top/post/vue%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC/</link>
      <pubDate>Wed, 15 Jan 2020 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/vue%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC/</guid>
      
        <description>

&lt;h3 id=&#34;两个版本对应的文件名&#34;&gt;两个版本对应的文件名&lt;/h3&gt;

&lt;p&gt;完整版：vue.js&lt;br&gt;
只包含运行时版(非完整版)：vue.runtime.js&lt;br&gt;&lt;/p&gt;

&lt;p&gt;完整版：同时包含编译器和运行时的版本。&lt;/p&gt;

&lt;p&gt;编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。&lt;/p&gt;

&lt;p&gt;运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。&lt;/p&gt;

&lt;h3 id=&#34;template-和-render-怎么用&#34;&gt;template 和 render 怎么用&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 需要编译器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Vue({
  template: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;lt;div&amp;gt;{{ hi }}&amp;lt;/div&amp;gt;&amp;#39;&lt;/span&gt;
})
&lt;span style=&#34;color:#228b22&#34;&gt;// 不需要编译器
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Vue({
  render (h) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; h(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.hi)
  }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yarn build 当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。&lt;/p&gt;

&lt;p&gt;因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本。&lt;/p&gt;

&lt;h3 id=&#34;两种版本区别&#34;&gt;两种版本区别&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/vue-version.png&#34; alt=&#34;vue-version&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最佳实践：总是使用非完整版，然后配合vue-loader和vue文件&lt;/p&gt;

&lt;p&gt;思路：&lt;br&gt;
1. 保证用户体验，用户下载的JS文件体积更小，但是只支持h函数&lt;br&gt;
2. 保证开发体验，开发者可以直接在vue文件里写html标签，而不写h函数&lt;br&gt;
3. 其他活让vue-loader去做&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;如何用-codesandbox-io-写-vue-代码&#34;&gt;如何用 codesandbox.io 写 Vue 代码&lt;/h3&gt;

&lt;p&gt;不进行注册登录 直接create a sandbox&lt;/p&gt;

&lt;p&gt;然后选择Explore Templates&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/codesandbox.png&#34; alt=&#34;codesandbox&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/code-sand-box-vue.png&#34; alt=&#34;code-sand-box-vue&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>浅析MVC</title>
      <link>http://wantsuchen.top/post/%E6%B5%85%E6%9E%90mvc/</link>
      <pubDate>Fri, 03 Jan 2020 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/%E6%B5%85%E6%9E%90mvc/</guid>
      
        <description>

&lt;h3 id=&#34;mvc三类对象&#34;&gt;MVC三类对象&lt;/h3&gt;

&lt;p&gt;MVC是一种架构设计模式，它通过关注点分离鼓励改进应用程序组织。&lt;/p&gt;

&lt;p&gt;MVC包括三类对象，将他们分离以提高灵活性和复用性。&lt;/p&gt;

&lt;p&gt;模型model用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。&lt;/p&gt;

&lt;p&gt;视图view是它在屏幕上的表示，描绘的是model的当前状态。当模型的数据发生变化，视图相应地得到刷新自己的机会。&lt;/p&gt;

&lt;p&gt;控制器controller定义用户界面对用户输入的响应方式，起到不同层面间的组织作用，用于控制应用程序的流程，它处理用户的行为和数据model上的改变。&lt;/p&gt;

&lt;p&gt;mvc伪代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//数据层，关于数据的操作放在这里
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; m = {
    &lt;span style=&#34;color:#228b22&#34;&gt;//初始化
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    data:{
    },
    &lt;span style=&#34;color:#228b22&#34;&gt;//更新数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    update(data) {
        
    },
    &lt;span style=&#34;color:#228b22&#34;&gt;//删除数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt;(data) {
    },
    &lt;span style=&#34;color:#228b22&#34;&gt;//获得数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    get(data) {

    },
}
&lt;span style=&#34;color:#228b22&#34;&gt;//视图层，关于视图的操作放在这里
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; v = {
    el:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;挂载点&amp;#39;&lt;/span&gt;,
    html:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;需要插入元素内的HTML内容&amp;#39;&lt;/span&gt;,
    init(){

    },
    &lt;span style=&#34;color:#228b22&#34;&gt;//渲染页面
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    render(data){

    },
}
&lt;span style=&#34;color:#228b22&#34;&gt;//控制层，其他相关的都放在这里
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; c = {
    init() {

    },
    &lt;span style=&#34;color:#228b22&#34;&gt;//调用数据层方法更改数据
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeData() {

    },
    &lt;span style=&#34;color:#228b22&#34;&gt;//调用视图层方法渲染页面
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    changeUI() {

    },
    &lt;span style=&#34;color:#228b22&#34;&gt;//监听数据改变
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    monitorData() {

    },
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;mvc-for-javascript&#34;&gt;MVC for JAVASCRIPT&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/javascriptMVC.png&#34; alt=&#34;MVC for JAVASCRIPT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，view承接了部分controller的功能，负责处理用户输入，但是不必了解下一步做什么。它依赖于一个controller为她做决定或处理用户事件。事实上，前端的view已经具备了独立处理用户事件的能力，如果每个事件都要流经controller，势必增加复杂性。同时，view也可以委托controller处理model的更改。model数据变化后通知view进行更新，显示给用户。这个过程是一个圆，一个循环的过程。&lt;/p&gt;

&lt;h3 id=&#34;eventbus&#34;&gt;EventBus&lt;/h3&gt;

&lt;p&gt;EventBus API包括&lt;/p&gt;

&lt;p&gt;绑定
eventBus.on(eventName, function[, obj]);&lt;/p&gt;

&lt;p&gt;触发
eventBus.emit(eventName[, sender][, data]);
eventBus.fire(eventName[, sender][, data]);
eventBus.trigger(eventName[, sender][, data]);&lt;/p&gt;

&lt;p&gt;解绑
eventBus.off(eventName[, function]);&lt;/p&gt;

&lt;p&gt;伪代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; EventBus{
    constructor() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;._eventBus = $(&lt;span style=&#34;color:#658b00&#34;&gt;window&lt;/span&gt;)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//绑定事件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    on(eventName, fn) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;._eventBus.on(eventName, fn)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//触发事件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    trigger(eventName, data) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;._eventBus.trigger(eventName, data)
    }
    &lt;span style=&#34;color:#228b22&#34;&gt;//解绑事件
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    off(eventName, fn) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;._eventBus.off(eventName, fn)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; myEventBus = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; eventBus();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;eventBus.on(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;data_completed&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; (sender, data, obj) {
}, { sign: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;F6243749AFF04C0581E1DD178A0B737A&amp;#34;&lt;/span&gt; });

eventBus.emit(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Data_Completed&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#658b00&#34;&gt;window&lt;/span&gt;, [&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;]);

eventBus.off(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Data_Completed&amp;#34;&lt;/span&gt;, f2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h3 id=&#34;表驱动编程&#34;&gt;表驱动编程&lt;/h3&gt;

&lt;p&gt;表格驱动的意义在于：逻辑和数据分离。&lt;/p&gt;

&lt;p&gt;在程序中，添加数据和逻辑的方式是不一样的，成本也是不一样的。简单的说，数据的添加是非常简单的；而逻辑的添加是更复杂的。&lt;/p&gt;

&lt;p&gt;比如说，国家简写转换，给一个国家全名，转换成国家简写，用 if－else 法就写成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; country_initial($country){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; ($country === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;China&amp;#34;&lt;/span&gt; ) {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;CHN&amp;#34;&lt;/span&gt;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; ($country === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;America&amp;#34;&lt;/span&gt;) {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;USA&amp;#34;&lt;/span&gt;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; ($country === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Japna&amp;#34;&lt;/span&gt;) {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;JPN&amp;#34;&lt;/span&gt;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;OTHER&amp;#34;&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我要增加一个国家，那么我要多加一个 else if 语句，那么我就是增加了一条逻辑&lt;/p&gt;

&lt;p&gt;如果改成表驱动法就是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; country_initial($country){
  $countryList=[
      &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;China&amp;#34;&lt;/span&gt;=&amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;CHN&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;America&amp;#34;&lt;/span&gt;=&amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;USA&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Japna&amp;#34;&lt;/span&gt;=&amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;JPN&amp;#34;&lt;/span&gt;,
    ];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(in_array($country, array_keys($countryList))) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; $countryList[$country];
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Other&amp;#34;&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我需要增加一个国家，我只需要在数组里面加个数据
如此一来，我就可以剥离这个数据与逻辑的关系了。&lt;/p&gt;

&lt;p&gt;逻辑和数据区分一目了然
关系表可以更换，比如国家表格可以是多语言的，中文版表格，英文版表格等，日语版表格，以及单元测试中，可以注入测试表格。
在单元测试中，逻辑必须测试，而数据无需测试。&lt;/p&gt;

&lt;p&gt;总结一下就是：&lt;/p&gt;

&lt;p&gt;逻辑与数据分离
逻辑修改成本巨大，数据修改成本极小
数据来源灵活，数据改变灵活&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;如何理解模块化&#34;&gt;如何理解模块化&lt;/h3&gt;

&lt;p&gt;模块化就是将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信&lt;/p&gt;

&lt;p&gt;模块化规范&lt;br&gt;
CommonJS&lt;/p&gt;

&lt;p&gt;Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。&lt;/p&gt;

&lt;p&gt;AMD&lt;br&gt;
CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。此外AMD规范比CommonJS规范在浏览器端实现要来着早。&lt;/p&gt;

&lt;p&gt;CMD&lt;br&gt;
CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;参考链接&lt;br&gt;
&lt;a href=&#34;https://efe.baidu.com/blog/mvc-deformation/&#34;&gt;https://efe.baidu.com/blog/mvc-deformation/&lt;/a&gt;
&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/1996ad3e09f9&#34;&gt;https://www.jianshu.com/p/1996ad3e09f9&lt;/a&gt;
&lt;br&gt;
&lt;a href=&#34;https://learnku.com/laravel/t/2712/the-meaning-of-the-if-else-code-style-into-the-table-driven-method&#34;&gt;https://learnku.com/laravel/t/2712/the-meaning-of-the-if-else-code-style-into-the-table-driven-method&lt;/a&gt;
&lt;br&gt;
&lt;a href=&#34;https://juejin.im/post/5c17ad756fb9a049ff4e0a62&#34;&gt;https://juejin.im/post/5c17ad756fb9a049ff4e0a62&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于我对前端的理解</title>
      <link>http://wantsuchen.top/post/%E6%88%91%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Tue, 24 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/%E6%88%91%E5%AF%B9%E5%89%8D%E7%AB%AF%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      
        <description>

&lt;p&gt;前端工程师是最贴近用户的程序员，前端工作可以实现页面交互，提升用户体验，参与项目开发，快速、高质量地完成实现效果图，精准到1px。
与团队成员如UI设计人员、产品经理、测试人员沟通。做好页面结构、页面重构，提升用户体验。处理hack，兼容性问题，写出优美的代码。好的代码应具有高复用率，低耦合度，易维护，易扩展等特点。此外，针对各种问题进行优化，拥抱最新的前端技术。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;font color=&#34;#8B3A3A&#34;&gt;目前，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。这样的现状就引发了一系列的问题。&lt;/p&gt;

&lt;p&gt;首先是前端的基础知识，常常看到一些大佬认为很基础的JavaScript语法的时候，惊呼“居然可以这样”。基础知识的欠缺会让人感觉束手束脚，限制了解决问题的思路。&lt;/p&gt;

&lt;p&gt;其次，技术上存在短板，就会导致前端开发者的上升通道不甚顺畅。特别是一些小公司的程序员，只能靠自己摸索，这样就很容易陷入重复性劳动的陷阱，最终耽误自己的职业发展。&lt;/p&gt;

&lt;p&gt;除此之外，前端工程师也会面临技术发展问题带来的挑战。前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。我们就拿 JavaScript 标准来说，ES6 中引入的新特性超过了过去十年的总和，新特性带来的实践就更多了，仅仅是一个 Proxy 特性的引入，就支持了 VueJS 从 2.0 到 3.0 的内核原理完全升级。缺少系统教育 + 技术快速革新，在这样的大环境下，前端工程师保持自学能力就显得尤其重要。
&lt;/font&gt;
&lt;hr&gt;&lt;/p&gt;

&lt;p&gt;前端技术大致分为几个部分&lt;/p&gt;

&lt;h3 id=&#34;html-和-css&#34;&gt;HTML 和 CSS&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/HTMLCSS.png&#34; alt=&#34;htmlcss&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 HTML 的部分，我们按照功能和语言来划分它的知识，HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类。&lt;/p&gt;

&lt;p&gt;我们都知道 HTML 的标签可以分为很多种，head 里面的我们称为元信息类标签，诸如 title、meta、style、link、base 这些，它们用来描述文档的一些基本信息。&lt;/p&gt;

&lt;p&gt;还有一类是一些诸如 section、nav 的标签，它们在视觉表现上跟 div 并没有区别，但是各有各的适用场景，我们把它们称作语义类标签。&lt;/p&gt;

&lt;p&gt;另外一类是 img、video、audio 之类的替换型媒体类标签，用来引入外部内容，平常开发中你也会经常用到。&lt;/p&gt;

&lt;p&gt;再有就是表单类的，比如 input、button。&lt;/p&gt;

&lt;p&gt;除了标签之外，我们还应该把 HTML 当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，包括HTML的语法和几个重要的语言机制：实体、命名空间。此外，包括HTML的补充标准：ARIA，它是HTML的扩展，在可访问性领域，它有至关重要的作用。&lt;/p&gt;

&lt;p&gt;CSS部分，按照惯例从语言和功能两个角度来说。在语言部分，从大到小包括CSS的各种语法结构，比如 @rule、选择器、单位等等。功能部分，我们大致可以分为布局、绘制和交互类。布局类中两个最常用的布局：正常流和弹性布局。绘制类分为图形相关的和文字相关的绘制。最后动画和其它交互。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/JS.png&#34; alt=&#34;js&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时。&lt;/p&gt;

&lt;p&gt;接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：&lt;/p&gt;

&lt;p&gt;数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。&lt;/p&gt;

&lt;p&gt;所谓的算法，就是 JavaScript 的执行过程。类型部分中，对象比其它所有类型加起来都要更为复杂，包括它的一些历史和设计思路。&lt;/p&gt;

&lt;p&gt;执行过程则按照从大结构到小结构的角度，从最顶层的程序与模块、事件循环和微任务，到函数、再到语句级的执行。从粗到细地了解执行过程。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;浏览器的实现原理和api&#34;&gt;浏览器的实现原理和API&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/浏览器的实现原理和API.png&#34; alt=&#34;浏览器的实现原理和API&#34; /&gt;&lt;/p&gt;

&lt;p&gt;浏览器部分包括浏览器的实现原理，这是深入理解 API 的基础。
从一般的浏览器设计出发，按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来解释浏览器的工作原理。在 API 部分，主要有：事件、DOM、CSSOM 几个部分，它们分别覆盖了交互、语义和可见效果。&lt;/p&gt;

&lt;p&gt;在最后我想说，我不想说对前端有什么理解我只是小弱鸡T-T&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS的继承</title>
      <link>http://wantsuchen.top/post/js%E7%9A%84%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 23 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/js%E7%9A%84%E7%BB%A7%E6%89%BF/</guid>
      
        <description>

&lt;h3 id=&#34;基于原型的继承&#34;&gt;基于原型的继承&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Animal () {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.x = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
}
Animal.prototype.move = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Animal-move&amp;#39;&lt;/span&gt;)
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Dog () {
  Animal.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, arguments)
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.xx = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; f = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {}
f.prototype = Animal.prototype
Dog.prototype = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; f()

Dog.prototype.constructor = Dog

Dog.prototype.run = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(){
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Dog-run&amp;#39;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; f = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {}
f.prototype = Animal.prototype
Dog.prototype = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; f()

Dog.prototype.constructor = Dog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;基于-class-的继承&#34;&gt;基于 class 的继承&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Animal {
  constructor () {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.x = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
  }
  move() {
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Animal-move&amp;#39;&lt;/span&gt;)
  }
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Dog &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; Animal {
  constructor () {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;()
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.xx = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
  }
  run() {
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Dog-run&amp;#39;&lt;/span&gt;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; Dog &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; Animal {
  constructor () {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;()
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>事件机制</title>
      <link>http://wantsuchen.top/post/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 23 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</guid>
      
        <description>

&lt;h3 id=&#34;什么是事件委托&#34;&gt;什么是事件委托&lt;/h3&gt;

&lt;p&gt;事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown&amp;hellip;&amp;hellip;）的函数委托到另一个元素；
一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。&lt;/p&gt;

&lt;h4 id=&#34;事件触发三阶段&#34;&gt;事件触发三阶段&lt;/h4&gt;

&lt;p&gt;首先事件触发有三个阶段&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从document往事件触发处传播，遇到注册的捕获事件会触发&lt;/li&gt;
&lt;li&gt;传播到事件触发处时触发注册的事件&lt;/li&gt;
&lt;li&gt;从事件触发处往document传播，遇到注册的冒泡事件会触发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和和捕获事件，事件触发会按照注册的顺序执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//以下会先打印冒泡然后是捕获
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;node.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, (event) =&amp;gt; {
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;冒泡&amp;#39;&lt;/span&gt;)
}, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;)
node.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, (event) =&amp;gt; {
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;捕获&amp;#39;&lt;/span&gt;)
}, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;注册事件&#34;&gt;注册事件&lt;/h4&gt;

&lt;p&gt;通常我们使用addEventListener注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值useCapture参数，该参数默认值为false。useCapture决定了注册的事件是捕获事件还是冒泡事件。对于对象参数。可以使用以下几个属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;capture,布尔值，和useCapture作用一样&lt;/li&gt;
&lt;li&gt;once, 布尔值，值为true表示该回调只会调用一次，调用后会移除监听&lt;/li&gt;
&lt;li&gt;passive，布尔值，表示永远不会调用preventDefault&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，我们只希望事件只触发在目标上，这时候可以使用stopPropagation来阻止事件的进一步传播。通常我们认为stopPropagation是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation同样也能实现阻止事件，此外还能阻止该事件目标执行别的注册事件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;node.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, (event)=&amp;gt;{
    event.stopImmediatePropagation()
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;冒泡&amp;#39;&lt;/span&gt;)
}, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;)
&lt;span style=&#34;color:#228b22&#34;&gt;//点击node只会执行上面的函数，该函数不会执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;node.addEventListener(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, (event)=&amp;gt;{
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;捕获&amp;#39;&lt;/span&gt;)
}, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;事件代理&#34;&gt;事件代理&lt;/h4&gt;

&lt;p&gt;如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&amp;lt;ul id=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;ul&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;li&amp;gt;&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &amp;lt;li&amp;gt;&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &amp;lt;li&amp;gt;&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &amp;lt;li&amp;gt;&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &amp;lt;li&amp;gt;&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/li&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/ul&amp;gt;&lt;/span&gt;
&amp;lt;script&amp;gt;
    &lt;span style=&#34;color:#cd5555&#34;&gt;```
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;    let ul = document.querySelector(&amp;#39;#ul&amp;#39;)
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;    ul.addEventListener(&amp;#39;click&amp;#39;, (event) =&amp;gt; {
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;        console.log(event.target)
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;    })
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;    ```&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;事件代理的方式相对于直接给目标注册事件，有以下优点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;节省内存&lt;/li&gt;
&lt;li&gt;不需要给子节点注销事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;怎么阻止默认动作&#34;&gt;怎么阻止默认动作&lt;/h3&gt;

&lt;p&gt;preventDefault它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;，提交按钮&lt;code&gt;&amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;&lt;/code&gt;等。当Event 对象的 cancelable为false时，表示没有默认行为，这时即使有默认行为，调用preventDefault也是不会起作用的。&lt;/p&gt;

&lt;h3 id=&#34;怎么阻止事件冒泡&#34;&gt;怎么阻止事件冒泡&lt;/h3&gt;

&lt;p&gt;stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。上面也说到，stopImmediatePropagation同样也能实现阻止事件，此外还能阻止该事件目标执行别的注册事件。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>跨域问题</title>
      <link>http://wantsuchen.top/post/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 22 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</guid>
      
        <description>

&lt;h3 id=&#34;什么是同源&#34;&gt;什么是同源&lt;/h3&gt;

&lt;p&gt;源 = 协议 + 域名 + 端口号&lt;br&gt;
window.origin或location.origin可以得到当前源&lt;/p&gt;

&lt;p&gt;如果两个url的&lt;font color=green&gt;协议 域名 端口号&lt;/font&gt;全都一致&lt;br&gt;
那么这两个url就是同源的！&lt;/p&gt;

&lt;h3 id=&#34;什么是跨域&#34;&gt;什么是跨域&lt;/h3&gt;

&lt;p&gt;因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax请求会失败
在一些情况下我们希望让不同源之间相互访问数据&lt;/p&gt;

&lt;h3 id=&#34;jsonp跨域&#34;&gt;JSONP跨域&lt;/h3&gt;

&lt;p&gt;JSONP就是利用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签没有跨域限制的漏洞。通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签指向一个需要访问的地址并提供一个回调函数当需要通讯时来接收数据
JSONP使用简单且兼容性不错，但是只限于get请求。
在开发中可能会遇到多个JSONP请求的回调函数名是相同的，这时候就需要自己封装一个JSONP&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; jsonp(url) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;((resolve, reject)=&amp;gt;{
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; random = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.random()
        &lt;span style=&#34;color:#658b00&#34;&gt;window&lt;/span&gt;[random] = (data) =&amp;gt; {
            resolve(data)
        }
        
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; script = &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.createElement(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;script&amp;#39;&lt;/span&gt;)
        script.src = &lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;url&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;?callback=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;random&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;
        script.type = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;text/javascript&amp;#39;&lt;/span&gt;
        script.onload = () =&amp;gt; {
            script.remove()
        }
        script.onerror = () =&amp;gt; {
            reject()
        }
        &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.body.appendChild(script)
    })
}

jsonp(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;http://127.0.0.1:8888/friends.js&amp;#39;&lt;/span&gt;).then(
    (data) =&amp;gt; {
        console.log(data)
    }
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;cors跨域&#34;&gt;CORS跨域&lt;/h3&gt;

&lt;p&gt;CORS需要浏览器和后端同时支持。IE8和9需要通过XDomainRequest来实现。&lt;/p&gt;

&lt;p&gt;浏览器会自动进行CORS通信，实现CORS通信的关键是后端。只要后端实现了CORS，就实现了跨域。&lt;/p&gt;

&lt;p&gt;服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(path === &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;/friends.json&amp;#39;&lt;/span&gt;){
    response.statusCode = &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt;
    response.setHeader(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;text/json;charset=utf-8&amp;#39;&lt;/span&gt;)
    response.setHeader(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Access-Control-Allow-Origin&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;http://127.0.0.1:8888&amp;#39;&lt;/span&gt;)
    response.write(fs.readFileSync(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;./public/friends.json&amp;#39;&lt;/span&gt;))
    response.end()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Promise介绍</title>
      <link>http://wantsuchen.top/post/promise%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 18 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/promise%E4%BB%8B%E7%BB%8D/</guid>
      
        <description>

&lt;h3 id=&#34;promise-的用途&#34;&gt;Promise 的用途&lt;/h3&gt;

&lt;p&gt;Promise是ES6新增的语法，解决了回调地狱的问题&lt;/p&gt;

&lt;p&gt;Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.&lt;/p&gt;

&lt;p&gt;Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象&lt;/p&gt;

&lt;p&gt;一个 Promise有以下几种状态:&lt;/p&gt;

&lt;p&gt;pending: 初始状态，既不是成功，也不是失败状态。
fulfilled: 意味着操作成功完成。
rejected: 意味着操作失败。
pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。&lt;/p&gt;

&lt;p&gt;因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。&lt;/p&gt;

&lt;h3 id=&#34;创建一个-new-promise&#34;&gt;创建一个 new Promise&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; fn(){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;((resolve, reject)=&amp;gt;{
        成功时调用 resolve(数据)
        失败时调用 reject(错误)
    })
}
fn().then(success, fail).then(success2, fail2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;使用-promise-prototype-then&#34;&gt;使用 Promise.prototype.then&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; p1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  resolve(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;成功！&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color:#228b22&#34;&gt;// or
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// reject(new Error(&amp;#34;出错了！&amp;#34;));
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;});

p1.then(value =&amp;gt; {
  console.log(value); &lt;span style=&#34;color:#228b22&#34;&gt;// 成功！
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}, reason =&amp;gt; {
  console.error(reason); &lt;span style=&#34;color:#228b22&#34;&gt;// 出错了！
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then函数会返回一个Promise实例，并且该返回值是一个新的实例而不是之前的实例
当一个值只是从一个 then 内部返回时，它将等价地返回 Promise.resolve(&amp;lt;由被调用的处理程序返回的值&amp;gt;)。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; p2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(resolve, reject) {
  resolve(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
});

p2.then(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(value) {
  console.log(value); &lt;span style=&#34;color:#228b22&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; value + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
}).then(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(value) {
  console.log(value + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; - A synchronous value works&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color:#228b22&#34;&gt;//2 - A synchronous value works
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;});

p2.then(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(value) {
  console.log(value); &lt;span style=&#34;color:#228b22&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;使用-promise-all&#34;&gt;使用 Promise.all&lt;/h3&gt;

&lt;p&gt;Promise.all([promise1, promise2]).then(success1, fail1)&lt;br&gt;
promise1和promise2都成功才会调用success1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; p1 = &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;.resolve(&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; p2 = &lt;span style=&#34;color:#b452cd&#34;&gt;1337&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; p3 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;((resolve, reject) =&amp;gt; {
  setTimeout(resolve, &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;);
}); 

&lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;.all([p1, p2, p3]).then(values =&amp;gt; { 
  console.log(values); &lt;span style=&#34;color:#228b22&#34;&gt;// [3, 1337, &amp;#34;foo&amp;#34;] 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;使用-promise-race&#34;&gt;使用 Promise.race&lt;/h3&gt;

&lt;p&gt;Promise.race([promise1, promise2]).then(success1, fail1)&lt;br&gt;
方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; promise1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(resolve, reject) {
    setTimeout(resolve, &lt;span style=&#34;color:#b452cd&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;one&amp;#39;&lt;/span&gt;);
});

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; promise2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(resolve, reject) {
    setTimeout(resolve, &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;two&amp;#39;&lt;/span&gt;);
});

&lt;span style=&#34;color:#658b00&#34;&gt;Promise&lt;/span&gt;.race([promise1, promise2]).then(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(value) {
  console.log(value);
  &lt;span style=&#34;color:#228b22&#34;&gt;// Both resolve, but promise2 is faster
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;});
&lt;span style=&#34;color:#228b22&#34;&gt;// expected output: &amp;#34;two&amp;#34;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>JS数组去重</title>
      <link>http://wantsuchen.top/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Tue, 17 Dec 2019 13:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      
        <description>

&lt;p&gt;著名面试题：
如何实现数组去重？
假设有数组 array = [1,5,2,3,4,2,3,1,3,4]
你要写一个函数 unique，使得
unique(array) 的值为 [1,5,2,3,4]
也就是把重复的值都去掉，只保留不重复的值。&lt;/p&gt;

&lt;p&gt;一个答案不使用 Set 实现
我们可以先使用sort()将数组进行排序
然后比较相邻元素是否相等，从而排除重复项&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr = [&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;]
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; unique (array) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr = array.sort()
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; result = [arr[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;]]
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;; i &amp;lt; arr.length; i++) {
        arr[i] !== arr[i-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;] &amp;amp;&amp;amp; result.push(arr[i])
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; result
}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用 Set&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr = [&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;]
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; unique (array) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Array&lt;/span&gt;.from(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Set(arr))
  &lt;span style=&#34;color:#228b22&#34;&gt;//或者[...new Set(arr)]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面方案的缺点是不支持对象去重，数组中出现对象的时候会出现问题&lt;/p&gt;

&lt;p&gt;我们可以使用 Map / WeakMap 以支持对象去重。&lt;/p&gt;

&lt;h4 id=&#34;map去重&#34;&gt;Map去重&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr = [
    {key: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;},
    {key: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;},
    {value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;, key: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;},
    {name:&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;}]
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; mySort(obj){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Object&lt;/span&gt;.keys(obj)
    .sort().reduce((a, v) =&amp;gt; {
    a[v] = obj[v]
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; a
    }, {})
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; unique (array) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr = array
  &lt;span style=&#34;color:#228b22&#34;&gt;//console.log(arr)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; hashMap = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Map()
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; result = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Array&lt;/span&gt;()
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; item = arr[i]
    item = mySort(item)
    item = JSON.stringify(item)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(hashMap.has(item)) { 
      hashMap.set(item, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;)
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {  
      hashMap.set(item, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)
      result.push(arr[i])
    }
  } 
  &lt;span style=&#34;color:#228b22&#34;&gt;//console.log(hashMap)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; result
}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遇到对象中嵌套对象会出现问题
&lt;hr&gt;&lt;/p&gt;

&lt;h4 id=&#34;weakmap去重&#34;&gt;WeakMap去重&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; ob1 = {key: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; ob2 = {value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;, key: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; arr = [ob1,ob1,ob2]
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; unique(array) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; wm = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; WeakMap()
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; array.length; i++){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(!wm.has(array[i])){
      wm.set(array[i], i)
    }
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; wm
}
unique(arr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;WeakMap {{&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;…&lt;/span&gt;} =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, {&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;…&lt;/span&gt;} =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;}
[[Entries]]
&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;: {&lt;span style=&#34;color:#658b00&#34;&gt;Object&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;}
key: {key: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;key&amp;#34;&lt;/span&gt;, value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;}
value: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;: {&lt;span style=&#34;color:#658b00&#34;&gt;Object&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;}
key: {value: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;, key: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;key&amp;#34;&lt;/span&gt;}
value: &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
__proto__: WeakMap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遇到let arr = [&lt;br&gt;
    {key: &amp;lsquo;key&amp;rsquo;, value: &amp;lsquo;value&amp;rsquo;},&lt;br&gt;
    {key: &amp;lsquo;key&amp;rsquo;, value: &amp;lsquo;value&amp;rsquo;},&lt;br&gt;
    {value: &amp;lsquo;value&amp;rsquo;, key: &amp;lsquo;key&amp;rsquo;},&lt;br&gt;
    {name:&amp;lsquo;name&amp;rsquo;}]&lt;br&gt;
会出现问题&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>http知识点</title>
      <link>http://wantsuchen.top/post/http%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Thu, 12 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/http%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      
        <description>

&lt;h2 id=&#34;一-http-响应状态码&#34;&gt;一 HTTP 响应状态码&lt;/h2&gt;

&lt;p&gt;HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：&lt;br&gt;
1. 信息响应(100–199)&lt;br&gt;
2. 成功响应(200–299)&lt;br&gt;
3. 重定向(300–399)&lt;br&gt;
4. 客户端错误(400–499)&lt;br&gt;
5. 服务器错误 (500–599)。&lt;br&gt;
状态代码由 section 10 of RFC 2616定义&lt;/p&gt;

&lt;h3 id=&#34;信息响应&#34;&gt;信息响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
100 Continue&lt;br&gt;
这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;102 Processing (WebDAV)&lt;br&gt;
此代码表示服务器已收到并正在处理该请求，但没有响应可用。&lt;/p&gt;

&lt;p&gt;103 Early Hints
此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;成功响应&#34;&gt;成功响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
200 OK&lt;br&gt;
请求成功。&lt;br&gt;
成功的含义取决于HTTP方法：&lt;br&gt;
GET：资源已被提取并在消息正文中传输。&lt;br&gt;
POST：描述动作结果的资源在消息体中传输。&lt;br&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
201 Created
该请求已成功，并因此创建了一个新的资源。这通常是在POST请求.
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
202 Accepted
请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
204 No Content
服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。
&lt;br&gt;
205 Reset Content
服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。
&lt;br&gt;
206 Partial Content
服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。&lt;br&gt;
&lt;hr&gt;

### 重定向
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
301 Moved Permanently&lt;br&gt;
被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。&lt;br&gt;如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
302 Found&lt;br&gt;
请求的资源现在临时从不同的 URI 响应请求。&lt;br&gt;由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

303 See Other
对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
304 Not Modified
如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
307 Temporary Redirect&lt;br&gt;
请求的资源现在临时从不同的URI响应请求。&lt;br&gt;由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
&lt;br&gt;&lt;br&gt;
308 Permanent Redirect&lt;br&gt;
这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 &lt;br&gt;这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;hr&gt;

&lt;h3 id=&#34;客户端响应&#34;&gt;客户端响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
400 Bad Request&lt;br&gt;
1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;401 Unauthorized&lt;br&gt;
当前请求需要用户验证。&lt;br&gt;
该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
403 Forbidden&lt;br&gt;
服务器已经理解请求，但是拒绝执行它。&lt;br&gt;与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
404 Not Found&lt;br&gt;
请求失败，请求所希望得到的资源未被在服务器上发现。&lt;br&gt;
没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
408 Request Timeout&lt;br&gt;
请求超时。&lt;br&gt;客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;410 Gone
被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。&lt;/p&gt;

&lt;p&gt;411 Length Required
服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。&lt;/p&gt;

&lt;p&gt;413 Payload Too Large
服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/p&gt;

&lt;p&gt;414 URI Too Long
请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。&lt;/p&gt;

&lt;p&gt;418 I&amp;rsquo;m a teapot
服务器拒绝尝试用 “茶壶冲泡咖啡”。&lt;/p&gt;

&lt;p&gt;429 Too Many Requests
用户在给定的时间内发送了太多请求（“限制请求速率”）。&lt;/p&gt;

&lt;p&gt;431 Request Header Fields Too Large
服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。&lt;/p&gt;

&lt;p&gt;451 Unavailable For Legal Reasons
用户请求非法资源，例如：由政府审查的网页。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;服务端响应&#34;&gt;服务端响应&lt;/h3&gt;

&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
500 Internal Server Error
服务器遇到了不知道如何处理的情况。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;501 Not Implemented
此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。&lt;/p&gt;

&lt;p&gt;502 Bad Gateway
此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。
&lt;table&gt;
&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;
503 Service Unavailable&lt;br&gt;
服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 &lt;br&gt;
请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
504 Gateway Timeout
当服务器作为网关，不能及时得到响应时返回此错误代码。&lt;/p&gt;

&lt;p&gt;505 HTTP Version Not Supported
服务器不支持请求中所使用的HTTP协议版本。&lt;/p&gt;

&lt;p&gt;511 Network Authentication Required
状态码指示客户端需要进行身份验证才能获得网络访问权限。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>闭包和执行上下文</title>
      <link>http://wantsuchen.top/post/%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Tue, 10 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      
        <description>

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/js0.png&#34; alt=&#34;闭包与函数&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-什么是闭包&#34;&gt;一 什么是闭包？&lt;/h2&gt;

&lt;p&gt;闭包翻译自英文单词closure，这是个不太好翻译的词。编译原理中，它是处理语法产生式的一个步骤；而在编程语言领域，它表示一种函数。&lt;/p&gt;

&lt;p&gt;闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。&lt;/p&gt;

&lt;p&gt;这个古典的闭包定义中，闭包包含两个部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境部分

&lt;ul&gt;
&lt;li&gt;环境&lt;/li&gt;
&lt;li&gt;标识符列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表达式部分&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在JavaScript中找到对应的闭包组成部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境部分

&lt;ul&gt;
&lt;li&gt;环境：函数的词法环境（执行上下文的一部分）&lt;/li&gt;
&lt;li&gt;标识符列表：函数中用到的未声明的变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表达式部分：函数体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;请看下面的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; init() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Mozilla&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#228b22&#34;&gt;// name 是一个被 init 创建的局部变量
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; displayName() { &lt;span style=&#34;color:#228b22&#34;&gt;// displayName() 是内部函数,一个闭包
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        alert(name); &lt;span style=&#34;color:#228b22&#34;&gt;// 使用了父函数中声明的变量
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    displayName();
}
init();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数，仅在该函数体内可被获取。请注意，displayName() 内没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。&lt;/p&gt;

&lt;p&gt;这个词法作用域的例子描述了引擎是如何解析嵌套函数中的变量的。&lt;br&gt;
&lt;font color=&#34;#00796B&#34;&gt;词法（lexical）一词表明，词法作用域根据声明变量的位置来确定该变量可被访问的位置。嵌套函数可获取声明于外部作用域的函数。&lt;/font&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;现在来考虑以下例子 ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; makeFunc() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Mozilla&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; displayName() {
        alert(name);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; displayName;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; myFunc = makeFunc();
myFunc();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行这段代码和之前的 init() 示例的效果完全一样。其中的不同 — 也是有意思的地方 — 在于内部函数 displayName() 在执行前，被外部函数返回。&lt;/p&gt;

&lt;p&gt;这个谜题的答案是，&lt;font color=&#34;#00796B&#34;&gt;JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。&lt;/font&gt;在我们的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;下面是一个更有意思的示例 — makeAdder 函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; makeAdder(x) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(y) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; x + y;
  };
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; add5 = makeAdder(&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; add10 = makeAdder(&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;);

console.log(add5(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;));  &lt;span style=&#34;color:#228b22&#34;&gt;// 7
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(add10(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;)); &lt;span style=&#34;color:#228b22&#34;&gt;// 12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。&lt;/p&gt;

&lt;p&gt;从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。&lt;/p&gt;

&lt;p&gt;add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。&lt;/p&gt;

&lt;h2 id=&#34;二-闭包的用途是什么&#34;&gt;二 闭包的用途是什么？&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。&lt;/p&gt;

&lt;p&gt;在 Web 中，你想要这样做的情况特别常见。大部分我们所写的 JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。&lt;/p&gt;

&lt;p&gt;假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如header）的字号：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;body&lt;/span&gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;font-family&lt;/span&gt;: Helvetica, Arial, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sans-serif&lt;/span&gt;;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;font-size&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt;;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h1&lt;/span&gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;font-size&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;1.5&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;em&lt;/span&gt;;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;h2&lt;/span&gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;font-size&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;1.2&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;em&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的文本尺寸调整按钮可以修改 body 元素的 font-size 属性，由于我们使用相对单位，页面中的其它元素也会相应地调整。&lt;/p&gt;

&lt;p&gt;以下是 JavaScript：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; makeSizer(size) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.body.style.fontSize = size + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;px&amp;#39;&lt;/span&gt;;
  };
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; size12 = makeSizer(&lt;span style=&#34;color:#b452cd&#34;&gt;12&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; size14 = makeSizer(&lt;span style=&#34;color:#b452cd&#34;&gt;14&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; size16 = makeSizer(&lt;span style=&#34;color:#b452cd&#34;&gt;16&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;size12，size14 和 size16 三个函数将分别把 body 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;size-12&amp;#39;&lt;/span&gt;).onclick = size12;
&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;size-14&amp;#39;&lt;/span&gt;).onclick = size14;
&lt;span style=&#34;color:#658b00&#34;&gt;document&lt;/span&gt;.getElementById(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;size-16&amp;#39;&lt;/span&gt;).onclick = size16;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;href&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;#&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;size-12&amp;#34;&lt;/span&gt;&amp;gt;12&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;a&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;href&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;#&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;size-14&amp;#34;&lt;/span&gt;&amp;gt;14&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;a&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;href&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;#&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;size-16&amp;#34;&lt;/span&gt;&amp;gt;16&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;a&lt;/span&gt;&amp;gt; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。&lt;/p&gt;

&lt;p&gt;而 JavaScript 没有这种原生支持，但&lt;font color=&#34;#00796B&#34;&gt;我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; Counter = (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; privateCounter = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; changeBy(val) {
    privateCounter += val;
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; {
    increment: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
      changeBy(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    },
    decrement: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
      changeBy(-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    },
    value: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; privateCounter;
    }
  }   
})();

console.log(Counter.value()); &lt;span style=&#34;color:#228b22&#34;&gt;/* logs 0 */&lt;/span&gt;
Counter.increment();
Counter.increment();
console.log(Counter.value()); &lt;span style=&#34;color:#228b22&#34;&gt;/* logs 2 */&lt;/span&gt;
Counter.decrement();
console.log(Counter.value()); &lt;span style=&#34;color:#228b22&#34;&gt;/* logs 1 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。&lt;/p&gt;

&lt;p&gt;该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。&lt;/p&gt;

&lt;p&gt;这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。&lt;/p&gt;

&lt;p&gt;你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量Counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; makeCounter = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; privateCounter = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; changeBy(val) {
    privateCounter += val;
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; {
    increment: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
      changeBy(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    },
    decrement: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
      changeBy(-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
    },
    value: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; privateCounter;
    }
  }  
};

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; Counter1 = makeCounter();
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; Counter2 = makeCounter();
console.log(Counter1.value()); &lt;span style=&#34;color:#228b22&#34;&gt;/* logs 0 */&lt;/span&gt;
Counter1.increment();
Counter1.increment();
console.log(Counter1.value()); &lt;span style=&#34;color:#228b22&#34;&gt;/* logs 2 */&lt;/span&gt;
Counter1.decrement();
console.log(Counter1.value()); &lt;span style=&#34;color:#228b22&#34;&gt;/* logs 1 */&lt;/span&gt;
console.log(Counter2.value()); &lt;span style=&#34;color:#228b22&#34;&gt;/* logs 0 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意两个计数器 Counter1 和 Counter2 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 privateCounter 。&lt;/p&gt;

&lt;p&gt;每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。&lt;/font&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;此外，我们可以通过闭包特性，将代码封装，等待时机成熟的时候再使用，比如实现柯里化和反柯里化。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-闭包的缺点是什么&#34;&gt;三 闭包的缺点是什么？&lt;/h2&gt;

&lt;p&gt;如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。&lt;/p&gt;

&lt;p&gt;例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; MyObject(name, message) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name.toString();
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.message = message.toString();
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.getName = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name;
  };

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.getMessage = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.message;
  };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; MyObject(name, message) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name.toString();
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.message = message.toString();
}
&lt;span style=&#34;color:#228b22&#34;&gt;// 不建议重新定义原型
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// MyObject.prototype = {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//   getName: function() {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//     return this.name;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//   },
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//   getMessage: function() {
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//     return this.message;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//   }
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// };
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;MyObject.prototype.getName = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name;
};
MyObject.prototype.getMessage = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.message;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;此外，IE浏览器存有bug，IE在我们使用完闭包之后，依然回收不了闭包里面引用的变量。
但是这是 IE 的问题，不是闭包的问题。参见司徒正美的&lt;a href=&#34;https://www.cnblogs.com/rubylouvre/p/3345294.html&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>apply,call和bind</title>
      <link>http://wantsuchen.top/post/applycall%E5%92%8Cbind/</link>
      <pubDate>Sat, 07 Dec 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/applycall%E5%92%8Cbind/</guid>
      
        <description>

&lt;h2 id=&#34;一-apply&#34;&gt;一 apply&lt;/h2&gt;

&lt;h3 id=&#34;语法&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;func.apply(thisArg, [argsArray])&lt;/p&gt;

&lt;h4 id=&#34;参数&#34;&gt;参数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisArg
可选的。在 func 函数运行时使用的 this 值。
（注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;argsArray
可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。
如果该参数的值为 null 或  undefined，则表示不需要传入任何参数。
(从ECMAScript 5 开始可以使用类数组对象。)&lt;/p&gt;

&lt;h4 id=&#34;返回值&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;调用这个指定this值(thisArg)和参数([argsArray])的函数(func)
调用函数的结果即它的返回值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; numbers = [&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt;];

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; max = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.max.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, numbers);

console.log(max);
&lt;span style=&#34;color:#228b22&#34;&gt;// expected output: 7
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; min = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.min.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, numbers);

console.log(min);
&lt;span style=&#34;color:#228b22&#34;&gt;// expected output: 2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;//结果
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//&amp;gt; 7
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//&amp;gt; 2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;1. 用 apply 将数组添加到另一个数组&lt;/font&gt;&lt;br&gt;
我们可以使用push将元素追加到数组中。并且，因为push接受可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，在这种情况下，concat确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组。在这种情况下我们可以使用apply&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; array = [&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;];
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; elements = [&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;];
array.push.apply(array, elements);
console.info(array); &lt;span style=&#34;color:#228b22&#34;&gt;// [&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, 0, 1, 2]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;2. 使用apply和内置函数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/* 找出数组中最大/小的数字 */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; numbers = [&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt;];

&lt;span style=&#34;color:#228b22&#34;&gt;/* 应用(apply) Math.min/Math.max 内置函数完成 */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; max = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.max.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, numbers); &lt;span style=&#34;color:#228b22&#34;&gt;/* 基本等同于 Math.max(numbers[0], ...) 或 Math.max(5, 6, ..) */&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; min = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.min.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, numbers);

&lt;span style=&#34;color:#228b22&#34;&gt;/* 代码对比： 用简单循环完成 */&lt;/span&gt;
max = -&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Infinity&lt;/span&gt;, min = +&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Infinity&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; numbers.length; i++) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (numbers[i] &amp;gt; max)
    max = numbers[i];
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (numbers[i] &amp;lt; min) 
    min = numbers[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是当心：如果用上面的方式调用apply，会有超出JavaScript引擎的参数长度限制的风险。当你对一个方法传入非常多的参数（比如一万个）时，就非常有可能会导致越界问题, 这个临界值是根据不同的 JavaScript 引擎而定的（JavaScript 核心中已经做了硬编码  参数个数限制在65536），因为这个限制（实际上也是任何用到超大栈空间的行为的自然表现）是未指定的. 有些引擎会抛出异常。更糟糕的是其他引擎会直接限制传入到方法的参数个数，导致参数丢失。举个例子：如果某个引擎限制了方法参数最多为4个（实际真正的参数个数限制当然要高得多了, 这里只是打个比方）, 上面的代码中, 真正通过 apply传到目标方法中的参数为 5, 6, 2, 3 而不是完整的数组。&lt;/p&gt;

&lt;p&gt;如果你的参数数组可能非常大，那么推荐使用下面这种策略来处理：将参数数组切块后循环传入目标方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; minOfArray(arr) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; min = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;Infinity&lt;/span&gt;;
  &lt;span style=&#34;color:#228b22&#34;&gt;// let QUANTUM = 32768;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; QUANTUM = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, len = arr.length; i &amp;lt; len; i += QUANTUM) {
    &lt;span style=&#34;color:#228b22&#34;&gt;//防止越界
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; rightIndex = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.min(i + QUANTUM, len);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; origin = arr.slice(i, rightIndex);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; submin = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.min.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, origin);
    min = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.min(submin, min);
  }

  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; min;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; min = minOfArray([&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt;]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;font color=&#34;#00796B&#34;&gt;3. 使用apply来链接构造器&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;你可以使用apply来链接一个对象构造器，类似于Java。在接下来的例子中我们会创建一个全局Function 对象的construct方法 ，来使你能够在构造器中使用一个类数组对象而非参数列表。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#658b00&#34;&gt;Function&lt;/span&gt;.prototype.construct = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; (aArgs) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; oNew = &lt;span style=&#34;color:#658b00&#34;&gt;Object&lt;/span&gt;.create(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.prototype);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.apply(oNew, aArgs);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; oNew;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;二-call&#34;&gt;二 call&lt;/h2&gt;

&lt;h3 id=&#34;语法-1&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;function.call(thisArg, arg1, arg2, &amp;hellip;)&lt;/p&gt;

&lt;h4 id=&#34;参数-1&#34;&gt;参数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisArg
可选的。在 func 函数运行时使用的 this 值。
（注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arg1, arg2, &amp;hellip;
指定的参数列表。&lt;/p&gt;

&lt;h4 id=&#34;返回值-1&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;使用调用者提供的 this 值(thisArg)和参数(arg1, arg2, &amp;hellip;)调用该函数(function)
调用函数的结果即它的返回值。
若该方法没有返回值，则返回 undefined。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; numbers = [&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt;];

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; max = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.max.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, numbers);

console.log(max);
&lt;span style=&#34;color:#228b22&#34;&gt;// expected output: 7
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; min = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.min.apply(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, numbers);

console.log(min);
&lt;span style=&#34;color:#228b22&#34;&gt;// expected output: 2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结果
&amp;gt; 7
&amp;gt; 2&lt;/p&gt;

&lt;h3 id=&#34;示例-1&#34;&gt;示例&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用父构造函数&lt;br&gt;
在一个子构造函数中，你可以通过调用父构造函数的 call 方法来实现继承，类似于 Java 中的写法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Product(name, price) {
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.price = price;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Food(name, price) {
Product.call(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, name, price);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.category = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;food&amp;#39;&lt;/span&gt;;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; Toy(name, price) {
Product.call(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;, name, price);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.category = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;toy&amp;#39;&lt;/span&gt;;
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; cheese = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Food(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;feta&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; fun = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Toy(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;robot&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;40&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用 Food 和 Toy 构造函数创建的对象实例都会拥有在 Product 构造函数中添加的 name 属性和 price 属性,但 category 属性是在各自的构造函数中定义的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用匿名函数
在下例中的 for 循环体内，我们创建了一个匿名函数，然后通过调用该函数的 call 方法，将每个数组元素作为指定的 this 值执行了那个匿名函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; animals = [
{ species: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Lion&amp;#39;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;King&amp;#39;&lt;/span&gt; },
{ species: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Whale&amp;#39;&lt;/span&gt;, name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Fail&amp;#39;&lt;/span&gt; }
];

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; animals.length; i++) {
(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(i) {
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.print = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#&amp;#39;&lt;/span&gt; + i + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; + &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.species
              + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;: &amp;#39;&lt;/span&gt; + &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.name);
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.print();
}).call(animals[i], i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个匿名函数的主要目的是给每个数组元素对象添加一个 print 方法，这个 print 方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为 this 值传入那个匿名函数（普通参数就可以），目的是为了演示 call 的用法。
3. 使用 call 方法调用函数并且指定上下文的 &amp;lsquo;this&amp;rsquo;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; greet() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; reply = [&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.animal, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;typically sleep between&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.sleepDuration].join(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;);
  console.log(reply);
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; obj = {
  animal: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;cats&amp;#39;&lt;/span&gt;, 
  sleepDuration: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;12 and 16 hours&amp;#39;&lt;/span&gt;
};

greet.call(obj);  &lt;span style=&#34;color:#228b22&#34;&gt;// cats typically sleep between 12 and 16 hours
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当调用 greet 方法的时候，该方法的this值会绑定到 obj 对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 call 方法调用函数并且不指定第一个参数（argument）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; sData = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Wisen&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; display() {
console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;sData value is %s &amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.sData);
}

display.call();  &lt;span style=&#34;color:#228b22&#34;&gt;// sData value is Wisen
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们调用了 display 方法，但并没有传递它的第一个参数。如果没有传递第一个参数，this 的值将会被绑定为全局对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; sData = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Wisen&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; display() {
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;sData value is %s &amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.sData);
}

display.call(); &lt;span style=&#34;color:#228b22&#34;&gt;// Cannot read the property of &amp;#39;sData&amp;#39; of undefined
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在严格模式下，this 的值将会是 undefined&lt;/p&gt;

&lt;h2 id=&#34;三-bind&#34;&gt;三 bind&lt;/h2&gt;

&lt;p&gt;bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; module = {
  x: &lt;span style=&#34;color:#b452cd&#34;&gt;42&lt;/span&gt;,
  getX: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.x;
  }
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; unboundGetX = module.getX;
console.log(unboundGetX()); &lt;span style=&#34;color:#228b22&#34;&gt;// The function gets invoked at the global scope
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// expected output: undefined
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
&lt;span style=&#34;color:#228b22&#34;&gt;// expected output: 42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;语法-2&#34;&gt;语法&lt;/h3&gt;

&lt;p&gt;function.bind(thisArg[, arg1[, arg2[, &amp;hellip;]]])&lt;/p&gt;

&lt;h4 id=&#34;参数-2&#34;&gt;参数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;thisArg
调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，执行作用域的 this 将被视为新函数的 thisArg。&lt;/li&gt;
&lt;li&gt;arg1, arg2, &amp;hellip;
当目标函数被调用时，被预置入绑定函数的参数列表中的参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;返回值-2&#34;&gt;返回值&lt;/h4&gt;

&lt;p&gt;返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。&lt;/p&gt;

&lt;h3 id=&#34;示例-2&#34;&gt;示例&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;#F5B041&#34;&gt;1. 创建绑定函数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.x = &lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;;    &lt;span style=&#34;color:#228b22&#34;&gt;// 在浏览器中，this 指向全局的 &amp;#34;window&amp;#34; 对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; module = {
  x: &lt;span style=&#34;color:#b452cd&#34;&gt;81&lt;/span&gt;,
  getX: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() { &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.x; }
};

module.getX(); &lt;span style=&#34;color:#228b22&#34;&gt;// 81
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; retrieveX = module.getX;
retrieveX();   
&lt;span style=&#34;color:#228b22&#34;&gt;// 返回 9 - 因为函数是在全局作用域中调用的
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;// 创建一个新函数，把 &amp;#39;this&amp;#39; 绑定到 module 对象
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 新手可能会将全局变量 x 与 module 的属性 x 混淆
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; boundGetX = retrieveX.bind(module);
boundGetX(); &lt;span style=&#34;color:#228b22&#34;&gt;// 81
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;font color=&#34;#F5B041&#34;&gt;2. 预设初始参数&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; list() {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;Array&lt;/span&gt;.prototype.slice.call(arguments);
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt; addArguments(arg1, arg2) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; arg1 + arg2
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; list1 = list(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#228b22&#34;&gt;// [1, 2, 3]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; result1 = addArguments(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;); &lt;span style=&#34;color:#228b22&#34;&gt;// 3
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;// 创建一个函数，它拥有预设参数列表。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; leadingThirtysevenList = list.bind(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;37&lt;/span&gt;);

&lt;span style=&#34;color:#228b22&#34;&gt;// 创建一个函数，它拥有预设的第一个参数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; addThirtySeven = addArguments.bind(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;37&lt;/span&gt;); 

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; list2 = leadingThirtysevenList(); 
&lt;span style=&#34;color:#228b22&#34;&gt;// [37]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; list3 = leadingThirtysevenList(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;); 
&lt;span style=&#34;color:#228b22&#34;&gt;// [37, 1, 2, 3]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; result2 = addThirtySeven(&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;); 
&lt;span style=&#34;color:#228b22&#34;&gt;// 37 + 5 = 42 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; result3 = addThirtySeven(&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;);
&lt;span style=&#34;color:#228b22&#34;&gt;// 37 + 5 = 42 ，第二个参数被忽略
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>jQuery设计思想</title>
      <link>http://wantsuchen.top/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</link>
      <pubDate>Sun, 10 Nov 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</guid>
      
        <description>

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery的基本设计思想和主要用法，就是选择某个网页元素，然后对其进行某种操作。&lt;br&gt;
这是它区别于其他Javascript库的根本特点。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-jquery如何获取元素&#34;&gt;一 jQuery如何获取元素&lt;/h2&gt;

&lt;p&gt;使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。
选择表达式可以是CSS选择器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/css-selector.png&#34; alt=&#34;css-selector&#34; /&gt;&lt;/p&gt;

&lt;p&gt;也可以是&lt;a href=&#34;(https://www.jquery123.com/category/selectors/)&#34;&gt;jQuery特有的表达式&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;a:first&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;//选择网页中第一个a元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tr:odd&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;//选择表格的奇数行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;#myForm :input&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;// 选择表单中的input元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div:visible&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;//选择可见的div元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div:gt(2)&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;// 选择所有的div元素，除了前三个
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div:animated&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;// 选择当前处于动画状态的div元素
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;二-jquery的链式操作是怎样的&#34;&gt;二 jQuery的链式操作是怎样的&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来。比如：&lt;/font&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;　$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;).find(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;h3&amp;#39;&lt;/span&gt;).eq(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;).html(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Hello&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分解开来，就是下面这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;//找到div元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  .find(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;h3&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;//选择其中的h3元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  .eq(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#228b22&#34;&gt;//选择第3个h3元素
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  .html(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Hello&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#228b22&#34;&gt;//将它的内容改为Hello
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，
这个jQuery对象中就包括了那些可以对选中元素做一些操作的函数
所以不同操作可以连在一起。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;jQuery还提供了.end()方法，使得结果集可以后退一步：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/end.png&#34; alt=&#34;end&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-jquery如何创建元素&#34;&gt;三 jQuery如何创建元素&lt;/h2&gt;

&lt;p&gt;创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;);

$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;lt;li class=&amp;#34;new&amp;#34;&amp;gt;new list item&amp;lt;/li&amp;gt;&amp;#39;&lt;/span&gt;);

$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;ul&amp;#39;&lt;/span&gt;).append(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;lt;li&amp;gt;list item&amp;lt;/li&amp;gt;&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;复制元素使用.clone()。&lt;/p&gt;

&lt;p&gt;删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。&lt;/p&gt;

&lt;p&gt;清空元素内容（但是不删除该元素）使用.empty()。&lt;/p&gt;

&lt;h2 id=&#34;四-jquery如何移动元素&#34;&gt;四 jQuery如何移动元素&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;假定我们选中了一个div元素，需要把它移动到p元素后面。&lt;/p&gt;

&lt;p&gt;第一种方法是使用.insertAfter()，把div元素移动p元素后面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;).insertAfter($(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;p&amp;#39;&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种方法是使用.after()，把p元素加到div元素前面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;p&amp;#39;&lt;/span&gt;).after($(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。&lt;/p&gt;

&lt;p&gt;使用这种模式的操作方法，一共有四对：
&lt;img src=&#34;http://wantsuchen.top/images/move.png&#34; alt=&#34;move&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-jquery如何修改元素的属性&#34;&gt;五 jQuery如何修改元素的属性&lt;/h2&gt;

&lt;p&gt;操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;0769AD&#34;&gt;jQuery设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即&amp;rdquo;取值器&amp;rdquo;与&amp;rdquo;赋值器&amp;rdquo;合一。到底是取值还是赋值，由函数的参数决定。&lt;/font&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;h1&amp;#39;&lt;/span&gt;).html(); &lt;span style=&#34;color:#228b22&#34;&gt;//html()没有参数，表示取出h1的值
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
$(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;h1&amp;#39;&lt;/span&gt;).html(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Hello&amp;#39;&lt;/span&gt;); &lt;span style=&#34;color:#228b22&#34;&gt;//html()有参数Hello，表示对h1进行赋值
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常见的取值和赋值函数如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/change.png&#34; alt=&#34;change&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。&lt;/p&gt;

&lt;p&gt;参考链接&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html&#34;&gt;jQuery设计思想-阮一峰&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS函数的执行时机</title>
      <link>http://wantsuchen.top/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Sat, 26 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      
        <description>

&lt;h2 id=&#34;一-为什么如下代码会打印-6-个-6&#34;&gt;一 为什么如下代码会打印 6 个 6&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;; i++){
  setTimeout(()=&amp;gt;{
    console.log(i)
  },&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当setTimeout()的毫秒数设置为0的时候，是要先执行完函数调用栈中的代码，然后立即调用定时器。&lt;/p&gt;

&lt;p&gt;因为定时器都被放在了一个队列中，等待上下文的可执行代码运行完毕后，才开始运行定时器，也就是定时器才刚开始计时。代码中声明一个let全局变量i，然后在for循环中改变i，所以在定时器的方法执行的时候，变量i已经变成了6，所以输出的全部是6。&lt;/p&gt;

&lt;h2 id=&#34;二-让上面代码打印-0-1-2-3-4-5-的方法&#34;&gt;二 让上面代码打印 0、1、2、3、4、5 的方法&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;; i++){
  setTimeout(() =&amp;gt; {
    console.log(i)
  }, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/setTimeout1.png&#34; alt=&#34;setTimeout1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;利用ES6 let命令声明变量块级作用域的概念，和前面for循环使用全局变量i不同，当前的i只在本轮循环有效， 所以每一次循环的i其实都是一个新的变量，所以5个setTimeout回调函数虽然都引用了变量i,但实际上这5个i是独立的，仅在自己的块级作用域内有效&lt;/p&gt;

&lt;h2 id=&#34;三-除了使用-for-let-配合-还有什么其他方法可以打印出-0-1-2-3-4-5&#34;&gt;三 除了使用 for let 配合，还有什么其他方法可以打印出 0、1、2、3、4、5&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;; i++) {
  &lt;span style=&#34;color:#228b22&#34;&gt;// j = i
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  !(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(j) { 
    setTimeout(() =&amp;gt; {
      console.log(j)
    }, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
  })(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/setTimeout2.png&#34; alt=&#34;setTimeout2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里通过立即执行函数创造了n个不同的函数作用域，给setTimeout传入n个不同的参数，所以就可以打印出0、1、2、3、4、5
此外，我们还可以&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; output = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(i) {
  setTimeout(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    console.log(i);
  }, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;);
};
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;; i++) {
  output.call(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;undefined&lt;/span&gt;, i); &lt;span style=&#34;color:#228b22&#34;&gt;// 这里传过去的 i 值被复制，而不是引用
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/setTimeout3.png&#34; alt=&#34;setTimeout3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;原理和上面相似，也是创造了n个不同的函数作用域，给setTimeout传入了n个不同的参数&lt;/p&gt;

&lt;p&gt;此外我们还可以利用setTimeout第三个参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;; i++) {
  setTimeout(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(i) {
    console.log(i);
  }, &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/setTimeout4.png&#34; alt=&#34;setTimeout4&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS排序算法</title>
      <link>http://wantsuchen.top/post/js%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/js%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-选择排序&#34;&gt;一 选择排序&lt;/h2&gt;

&lt;p&gt;选择排序 即在当前区间选出一个最小值和区间第一个数交换位置，区间大小减一&lt;br&gt;
一共有n个数， 第一次遍历n个数，第二次遍历n-1个数，以此类推，&lt;br&gt;
共遍历 n + (n - 1) + (n - 2) + &amp;hellip; + (n - n + 1) + (n - n) 次 (加0不影响最终结果)&lt;br&gt;
例如   数组一共有5个数，遍历 5 + 4 + 3 + 2 + 1 + 0 次&lt;br&gt;
也可以写作 n + &amp;hellip; + 3 + 2 + 1 + 0 = (n * (n + 1)) / 2 = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;(n^2) + (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)n &lt;br&gt;
时间复杂度O(n^2)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; log = console.log.bind(console)

&lt;span style=&#34;color:#228b22&#34;&gt;//求当前区间内最小值下标
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; minIndex = (numbers) =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; index = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;; i &amp;lt; numbers.length; i++){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(numbers[i] &amp;lt; numbers[index]){
      index = i
    }
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; index
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; swap = (array, i, j) =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; temp = array[i]
  array[i] = array[j]
  array[j] = temp
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; sort = (numbers) =&amp;gt; {
  &lt;span style=&#34;color:#228b22&#34;&gt;//遍历到区间只剩下两个数就可以停止了, 也就是i等于numbers.length - 2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;//如8个数 i等于numbers.length - 2 = 6, 区间是arr[6]-arr[7] 没有arr[8] :)
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; numbers.length - &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;; i++){
    log(&lt;span style=&#34;color:#cd5555&#34;&gt;`------`&lt;/span&gt;)
    log(&lt;span style=&#34;color:#cd5555&#34;&gt;`i: &lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;i&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    &lt;span style=&#34;color:#228b22&#34;&gt;//求当前区间内的最小值在整个数组内的下标
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//为当前区间内的最小值的下标 加 区间前面的数字个数
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//例如 [6,2,4,5]  1 + 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;//再比如 6,[2,4,5] 0 + 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; index = minIndex(numbers.slice(i)) + i
    log(&lt;span style=&#34;color:#cd5555&#34;&gt;`index: &lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;index&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    log(&lt;span style=&#34;color:#cd5555&#34;&gt;`min: &lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;numbers[index]&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(index!==i){
      swap(numbers, index, i)
      log(&lt;span style=&#34;color:#cd5555&#34;&gt;`swap &lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;index&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;${&lt;/span&gt;i&lt;span style=&#34;color:#cd5555&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;`&lt;/span&gt;)
      log(numbers)
    }
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; numbers
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;二-快速排序&#34;&gt;二 快速排序&lt;/h2&gt;

&lt;p&gt;快速排序,即取数组中间位置的数，比它小的数放在它的左边，比它大的放在右边
然后区间变为它的左边的数组成的数组 和 它的右边的数组成的数组
最后区间只剩一个数终止&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; quickSort = arr =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (arr.length &amp;lt;= &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) { 
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; arr; 
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; pivotIndex = &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.floor(arr.length / &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; pivot = arr.splice(pivotIndex, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;];
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; left = [];
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; right = [];
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (arr[i] &amp;lt; pivot) { 
      left.push(arr[i])
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; { 
      right.push(arr[i]) 
    }
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; quickSort(left).concat([pivot], quickSort(right))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;三-归并排序&#34;&gt;三 归并排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; merge = (a, b) =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (a.length === &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; b
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (b.length === &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; a
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; a[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;] &amp;gt; b[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;] ?
    [b[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;]].concat(merge(a, b.slice(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;))) :
    [a[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;]].concat(merge(a.slice(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;), b))
}

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; mergeSort = arr =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; k = arr.length
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (k === &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) { 
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; arr
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; left = arr.slice(&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.floor(k / &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;))
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; right = arr.slice(&lt;span style=&#34;color:#658b00&#34;&gt;Math&lt;/span&gt;.floor(k / &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;))
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; merge(mergeSort(left), mergeSort(right))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;四-计数排序&#34;&gt;四 计数排序&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; countSort = arr =&amp;gt; {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; hashTable = {}, max = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;, result = []
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++){ 
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(!(arr[i] &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;in&lt;/span&gt; hashTable)){ 
      hashTable[arr[i]] = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
    }&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
      hashTable[arr[i]] += &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(max &amp;lt; arr[i]) {
      max = arr[i]
    }
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; j = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; j &amp;lt;= max; j++){ 
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(j &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;in&lt;/span&gt; hashTable){
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; hashTable[j]; i++){
        result.push(j)
      }
    }
  }
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; result
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;时间不够，待更新&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS对象基本用法</title>
      <link>http://wantsuchen.top/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sun, 20 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-声明对象的两种语法&#34;&gt;一 声明对象的两种语法&lt;/h2&gt;

&lt;h3 id=&#34;对象的定义&#34;&gt;对象的定义&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;无序的数据集合&lt;/font&gt;&lt;br&gt;
&lt;font color=&#34;orange&#34;&gt;键值对的集合&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;对象的写法&#34;&gt;对象的写法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;let obj = {&#39;name&#39;: &#39;zwx&#39;, &#39;age&#39;: 18, }&lt;/code&gt;
&lt;code&gt;let obj = new Object({&#39;name&#39;: &#39;zwx&#39;})&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;细节&#34;&gt;细节&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;键名是字符串，可以包含任意Unicode字符&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;如果书写键名时省略引号，就只能按标识符规则书写&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;‘省略引号’也改变不了‘键名是个字符串’这个事实&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-如何删除对象的属性&#34;&gt;二 如何删除对象的属性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;delete obj.xxx&lt;/code&gt;或者&lt;code&gt;delete obj[&#39;xxx&#39;]&lt;/code&gt;
&lt;font color=&#34;orange&#34;&gt;即可删除obj的xxx属性&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;不含属性名&lt;/font&gt;
&lt;code&gt;&#39;xxx&#39; in obj === false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;含有属性名，但是值为undefined&lt;/font&gt;
&lt;code&gt;&#39;xxx&#39; in obj &amp;amp;&amp;amp; obj.xxx === undefined&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-如何查看对象的属性&#34;&gt;三 如何查看对象的属性&lt;/h2&gt;

&lt;h3 id=&#34;查看所有属性&#34;&gt;查看所有属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;查看自身所有属性&lt;/font&gt;
&lt;code&gt;Object.keys(obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;查看自身+共有属性&lt;/font&gt;
&lt;code&gt;console.dir(obj)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;判断一个属性是自身的还是共有的&lt;/font&gt;
&lt;code&gt;obj.hasOwnProperty(&#39;toString&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;查看属性&#34;&gt;查看属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;中括号语法：&lt;/font&gt;
&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt;
&lt;font color=&#34;orange&#34;&gt;点语法：&lt;/font&gt;
&lt;code&gt;obj.key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;优先使用&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt;&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;重点&#34;&gt;重点&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;obj.name 等价于 obj[&amp;lsquo;name&amp;rsquo;]&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; my = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;function&lt;/span&gt;(){
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; list = [&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;age&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;gender&amp;#39;&lt;/span&gt;]
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; person = {
  name: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;zwx&amp;#39;&lt;/span&gt;,
  age: &lt;span style=&#34;color:#b452cd&#34;&gt;18&lt;/span&gt;,
  gender: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;male&amp;#39;&lt;/span&gt;,
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; list.length; i++) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; name = list[i]
  &lt;span style=&#34;color:#228b22&#34;&gt;//person.name 等价于 person[&amp;#39;name&amp;#39;]
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;1.&amp;#39;&lt;/span&gt; + person.name)
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;2.&amp;#39;&lt;/span&gt; + person[name])
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/查看对象属性.png&#34; alt=&#34;查看对象属性&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;四-如何修改或增加对象的属性&#34;&gt;四 如何修改或增加对象的属性&lt;/h2&gt;

&lt;h3 id=&#34;修改或增加属性&#34;&gt;修改或增加属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;直接赋值&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;let obj = {name: &#39;zwx&#39;} // name是字符串&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj.name = &#39;zwx&#39; // name是字符串&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj[&#39;name&#39;] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;obj[&#39;na&#39; + &#39;me&#39;] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;let key = &#39;name&#39;; obj[key] = &#39;zwx&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;批量赋值&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.assign(obj, {age: 18, gender: &#39;male&#39;})&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;修改或增加共有属性&#34;&gt;修改或增加共有属性&lt;/h3&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;无法通过其中一个对象修改或增加他们的共有属性&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let obj = {}, obj2 = {} // 共有原型上的toString&lt;/code&gt;&lt;br&gt;
&lt;code&gt;obj.toString = &#39;xxx&#39;&lt;/code&gt; 只会修改自身的属性&lt;br&gt;
&lt;code&gt;obj2.toString&lt;/code&gt; 还是原型上的方法&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;我偏要修改或增加原型上的属性&lt;/font&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;obj.__proto__.toString = &#39;xxx&#39; // 不推荐用__proto__&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Object.prototype.toString = &#39;xxx&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;一般来说，不要修改原型，会引起很多问题&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;五-name-in-obj和obj-hasownproperty-name-的区别&#34;&gt;五 &amp;lsquo;name&amp;rsquo; in obj和obj.hasOwnProperty(&amp;lsquo;name&amp;rsquo;)的区别&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;prop in object&lt;/code&gt; 检查它（或其原型链）是否包含具有指定名称的属性&lt;/p&gt;

&lt;p&gt;in右操作数必须是一个对象值。&lt;/p&gt;

&lt;p&gt;如果使用 delete 运算符删除了一个属性，则 in 运算符对所删除属性返回 false。&lt;/p&gt;

&lt;p&gt;如果你只是将一个属性的值赋值为undefined，而没有删除它，则 in 运算仍然会返回true。&lt;/p&gt;

&lt;p&gt;如果一个属性是从原型链上继承来的，in 运算符也会返回 true。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;obj.hasOwnProperty(&#39;name&#39;)&lt;/code&gt; 方法会返回一个布尔值，指示对象自身属性中（非继承属性）是否具有指定的属性，
如果 object 具有带指定名称的属性，则 hasOwnProperty 方法返回 true，否则返回 false。此方法不会检查对象原型链中的属性；该属性必须是对象本身的一个成员。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; father = {money: &lt;span style=&#34;color:#b452cd&#34;&gt;9999&lt;/span&gt;}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;let&lt;/span&gt; son = &lt;span style=&#34;color:#658b00&#34;&gt;Object&lt;/span&gt;.create(father)
son.name = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;son&amp;#39;&lt;/span&gt;
console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;1.检查它（或其原型链）是否包含具有指定名称的属性&amp;#39;&lt;/span&gt;)
console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;money&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;in&lt;/span&gt; son) &lt;span style=&#34;color:#228b22&#34;&gt;//true
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;2.对象自身属性中（非继承属性）是否具有指定的属性&amp;#39;&lt;/span&gt;)
console.log(son.hasOwnProperty(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;money&amp;#39;&lt;/span&gt;)) &lt;span style=&#34;color:#228b22&#34;&gt;//false
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;http://wantsuchen.top/images/方法区别.png&#34; alt=&#34;方法区别&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS的基本语法</title>
      <link>http://wantsuchen.top/post/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 19:34:36 +0800</pubDate>
      
      <guid>http://wantsuchen.top/post/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      
        <description>

&lt;h2 id=&#34;一-表达式和语句&#34;&gt;一 表达式和语句&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句（statement）是为了完成某种任务而进行的操作&lt;/font&gt;，比如下面就是一行赋值语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let a = 1 + 3;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这条语句先用&lt;code&gt;let&lt;/code&gt;命令，声明了变量&lt;code&gt;a&lt;/code&gt;，然后将&lt;code&gt;1 + 3&lt;/code&gt;的运算结果赋值给变量&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + 3&lt;/code&gt;叫做表达式（expression）&lt;/p&gt;

&lt;p&gt;表达式指一个为了得到返回值的计算式。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；
表达式则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。
比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let a = 1 + 3 ; let b = &#39;abc&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;;;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的代码就表示3个空语句。&lt;/p&gt;

&lt;p&gt;表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + 3;&lt;/code&gt;
&lt;code&gt;&#39;abc&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面两行语句只是单纯地产生一个值，并没有任何实际的意义。&lt;/p&gt;

&lt;h2 id=&#34;二-标识符的规则&#34;&gt;二 标识符的规则&lt;/h2&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;标识符（identifier）指的是用来识别各种值的合法名称。&lt;/font&gt;最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;A&lt;/code&gt;是两个不同的标识符。&lt;/p&gt;

&lt;p&gt;标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript引擎遇到非法标识符，就会报错。&lt;/p&gt;

&lt;p&gt;简单说，标识符命名规则如下。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（&lt;code&gt;$&lt;/code&gt;）和下划线（&lt;code&gt;_&lt;/code&gt;）。
第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;。&lt;/font&gt;
下面这些都是合法的标识符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arg0&lt;/code&gt;
&lt;code&gt;_tmp&lt;/code&gt;
&lt;code&gt;$elem&lt;/code&gt;
&lt;code&gt;π&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面这些则是不合法的标识符。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;a  &lt;span style=&#34;color:#228b22&#34;&gt;// 第一个字符不能是数字
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;23&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// 同上
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;***  &lt;span style=&#34;color:#228b22&#34;&gt;// 标识符不能包含星号
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;a+b  &lt;span style=&#34;color:#228b22&#34;&gt;// 标识符不能包含加号
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;-d  &lt;span style=&#34;color:#228b22&#34;&gt;// 标识符不能包含减号或连词线
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中文是合法的标识符，可以用作变量名。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var 临时变量 = 1;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-if-else-条件语句&#34;&gt;三 if else 条件语句&lt;/h2&gt;

&lt;p&gt;if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，&lt;code&gt;true&lt;/code&gt;表示真，&lt;code&gt;false&lt;/code&gt;表示伪&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (布尔值)
  语句;

&lt;span style=&#34;color:#228b22&#34;&gt;// 或者
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (布尔值) 语句;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m === &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;)
  m = m + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码表示，只有在&lt;code&gt;m&lt;/code&gt;等于&lt;code&gt;3&lt;/code&gt;时，才会将其值加上&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m === &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;) {
  m += &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议总是在if语句中使用大括号，因为这样方便插入语句。&lt;/p&gt;

&lt;p&gt;注意，if后面的表达式之中，不要混淆赋值表达式（&lt;code&gt;=&lt;/code&gt;）、严格相等运算符（&lt;code&gt;===&lt;/code&gt;）和相等运算符（&lt;code&gt;==&lt;/code&gt;）。尤其是赋值表达式不具有比较作用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; x = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; y = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (x = y) {
  console.log(x);
}
&lt;span style=&#34;color:#228b22&#34;&gt;// &amp;#34;2&amp;#34;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的原意是，当&lt;code&gt;x&lt;/code&gt;等于&lt;code&gt;y&lt;/code&gt;的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将&lt;code&gt;y&lt;/code&gt;赋值给变量&lt;code&gt;x&lt;/code&gt;，再判断变量&lt;code&gt;x&lt;/code&gt;的值（等于&lt;code&gt;2&lt;/code&gt;）的布尔值（结果为&lt;code&gt;true&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。&lt;/font&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (x = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) { &lt;span style=&#34;color:#228b22&#34;&gt;// 不报错
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; = x) { &lt;span style=&#34;color:#228b22&#34;&gt;// 报错
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;代码块后面，还可以跟一个&lt;code&gt;else&lt;/code&gt;代码块，表示不满足条件时，所要执行的代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m === &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;) {
  &lt;span style=&#34;color:#228b22&#34;&gt;// 满足条件时，执行的语句
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
  &lt;span style=&#34;color:#228b22&#34;&gt;// 不满足条件时，执行的语句
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码判断变量&lt;code&gt;m&lt;/code&gt;是否等于&lt;code&gt;3&lt;/code&gt;，如果等于就执行&lt;code&gt;if&lt;/code&gt;代码块，否则执行&lt;code&gt;else&lt;/code&gt;代码块。&lt;/p&gt;

&lt;p&gt;对同一个变量进行多次判断时，多个&lt;code&gt;if...else&lt;/code&gt;语句可以连写在一起。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m === &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) {
  &lt;span style=&#34;color:#228b22&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m === &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) {
  &lt;span style=&#34;color:#228b22&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m === &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) {
  &lt;span style=&#34;color:#228b22&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
  &lt;span style=&#34;color:#228b22&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;else&lt;/code&gt;代码块总是与离自己最近的那个&lt;code&gt;if&lt;/code&gt;语句配对。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; m = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; n = &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m !== &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (n === &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码不会有任何输出，&lt;code&gt;else&lt;/code&gt;代码块不会得到执行，因为它跟着的是最近的那个&lt;code&gt;if&lt;/code&gt;语句，相当于下面这样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m !== &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (n === &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) {
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;);
  } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想让&lt;code&gt;else&lt;/code&gt;代码块跟随最上面的那个if语句，就要改变大括号的位置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (m !== &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) {
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (n === &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;) {
    console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;);
  }
} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;);
}
&lt;span style=&#34;color:#228b22&#34;&gt;// world
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;四-while-for-循环语句&#34;&gt;四 while for 循环语句&lt;/h2&gt;

&lt;h3 id=&#34;while语句&#34;&gt;While语句&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;While&lt;/code&gt;语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (条件)
  语句;

&lt;span style=&#34;color:#228b22&#34;&gt;// 或者
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (条件) 语句;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;while&lt;/code&gt;语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (条件) {
  语句;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是&lt;code&gt;while&lt;/code&gt;语句的一个例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt;) {
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;i 当前为：&amp;#39;&lt;/span&gt; + i);
  i = i + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码将循环100次，直到i等于100为止。&lt;/p&gt;

&lt;p&gt;下面的例子是一个无限循环，因为循环条件总是为真。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;) {
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Hello, world&amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;for语句&#34;&gt;for语句&lt;/h3&gt;

&lt;p&gt;for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (初始化表达式; 条件; 递增表达式)
  语句

&lt;span style=&#34;color:#228b22&#34;&gt;// 或者
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (初始化表达式; 条件; 递增表达式) {
  语句
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;for语句后面的括号里面，有三个表达式。&lt;/font&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;初始化表达式（initialize）&lt;/font&gt;：确定循环变量的初始值，只在循环开始时执行一次。&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;条件表达式（test）&lt;/font&gt;：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;orange&#34;&gt;递增表达式（increment）&lt;/font&gt;：每轮循环的最后一个操作，通常用来递增循环变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是一个例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; x = &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; x; i++) {
  console.log(i);
}
&lt;span style=&#34;color:#228b22&#34;&gt;// 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，初始化表达式是&lt;code&gt;var i = 0&lt;/code&gt;，即初始化一个变量&lt;code&gt;i&lt;/code&gt;；测试表达式是&lt;code&gt;i &amp;lt; x&lt;/code&gt;，即只要&lt;code&gt;i&lt;/code&gt;小于&lt;code&gt;x&lt;/code&gt;，就会执行循环；递增表达式是&lt;code&gt;i++&lt;/code&gt;，即每次循环结束后，&lt;code&gt;i&lt;/code&gt;增大&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所有&lt;code&gt;for&lt;/code&gt;循环，都可以改写成&lt;code&gt;while&lt;/code&gt;循环。上面的例子改为&lt;code&gt;while&lt;/code&gt;循环，代码如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; x = &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (i &amp;lt; x) {
  console.log(i);
  i++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; ( ; ; ){
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;Hello World&amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。&lt;/p&gt;

&lt;h2 id=&#34;五-break-continue-语句&#34;&gt;五 break continue 语句&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句用于跳出代码块或循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;(i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt;) {
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;i 当前为：&amp;#39;&lt;/span&gt; + i);
  i++;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i === &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码只会执行10次循环，一旦i等于10，就会跳出循环。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;循环也可以使用&lt;code&gt;break&lt;/code&gt;语句跳出循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;; i++) {
  console.log(i);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i === &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt;;
}
&lt;span style=&#34;color:#228b22&#34;&gt;// 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码执行到&lt;code&gt;i&lt;/code&gt;等于&lt;code&gt;3&lt;/code&gt;，就会跳出循环。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt;){
  i++;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; === &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;i 当前为：&amp;#39;&lt;/span&gt; + i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码只有在&lt;code&gt;i&lt;/code&gt;为奇数时，才会输出&lt;code&gt;i&lt;/code&gt;的值。如果&lt;code&gt;i&lt;/code&gt;为偶数，则直接进入下一轮循环。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;如果存在多重循环，不带参数的&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都只针对最内层循环。&lt;/font&gt;&lt;/p&gt;

&lt;h2 id=&#34;六-标签-label&#34;&gt;六 标签（label）&lt;/h2&gt;

&lt;p&gt;JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;label:
  语句
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。&lt;/p&gt;

&lt;p&gt;标签通常与&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句配合使用，跳出特定的循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;top:
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;; i++){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; j = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;; j++){
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i === &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; j === &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt; top;
      console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;i=&amp;#39;&lt;/span&gt; + i + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;, j=&amp;#39;&lt;/span&gt; + j);
    }
  }
&lt;span style=&#34;color:#228b22&#34;&gt;// i=0, j=0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=0, j=1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=0, j=2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=1, j=0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码为一个双重循环区块，&lt;code&gt;break&lt;/code&gt;命令后面加上了&lt;code&gt;top&lt;/code&gt;标签（注意，&lt;code&gt;top&lt;/code&gt;不用加引号），满足条件时，直接跳出双层循环。如果&lt;code&gt;break&lt;/code&gt;语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p&gt;

&lt;p&gt;标签也可以用于跳出代码块。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;foo: {
  console.log(&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt; foo;
  console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;本行不会输出&amp;#39;&lt;/span&gt;);
}
console.log(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;);
&lt;span style=&#34;color:#228b22&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// 2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码执行到&lt;code&gt;break foo&lt;/code&gt;，就会跳出区块。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句也可以与标签配合使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;top:
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;; i++){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;var&lt;/span&gt; j = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;; j &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;; j++){
      &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i === &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; j === &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt; top;
      console.log(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;i=&amp;#39;&lt;/span&gt; + i + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;, j=&amp;#39;&lt;/span&gt; + j);
    }
  }
&lt;span style=&#34;color:#228b22&#34;&gt;// i=0, j=0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=0, j=1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=0, j=2
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=1, j=0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=2, j=0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=2, j=1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// i=2, j=2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，&lt;code&gt;continue&lt;/code&gt;命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果&lt;code&gt;continue&lt;/code&gt;语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;orange&#34;&gt;面试相关题：&lt;/font&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//label
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;{
    top: x
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://wangdoc.com/javascript/index.html&#34;&gt;网道JavaScript 教程&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
